<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C# 12 Primary Constructors | Nicola Iarocci</title>
<meta name=keywords content="speaking,csharp,dotnet"><meta name=description content="I wrapped up my C# 12 session at the ABP Dotnet Conference 2024, and I wanted to share the take-home points, at least about the most relevant features in this language version. Posting the slides made no sense as they were minimal; all the content was packed in the live demo.
In a follow-up post, I plan to address Collection Expressions (done) and maybe &ldquo;type any aliases&rdquo;; this is about Primary Constructors."><meta name=author content><link rel=canonical href=https://nicolaiarocci.com/csharp-primary-constructors/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C# 12 Primary Constructors"><meta property="og:description" content="I wrapped up my C# 12 session at the ABP Dotnet Conference 2024, and I wanted to share the take-home points, at least about the most relevant features in this language version. Posting the slides made no sense as they were minimal; all the content was packed in the live demo.
In a follow-up post, I plan to address Collection Expressions (done) and maybe &ldquo;type any aliases&rdquo;; this is about Primary Constructors."><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/csharp-primary-constructors/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-05-09T18:04:39+02:00"><meta property="article:modified_time" content="2024-05-09T18:04:39+02:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="C# 12 Primary Constructors"><meta name=twitter:description content="I wrapped up my C# 12 session at the ABP Dotnet Conference 2024, and I wanted to share the take-home points, at least about the most relevant features in this language version. Posting the slides made no sense as they were minimal; all the content was packed in the live demo.
In a follow-up post, I plan to address Collection Expressions (done) and maybe &ldquo;type any aliases&rdquo;; this is about Primary Constructors."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"C# 12 Primary Constructors","item":"https://nicolaiarocci.com/csharp-primary-constructors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C# 12 Primary Constructors","name":"C# 12 Primary Constructors","description":"I wrapped up my C# 12 session at the ABP Dotnet Conference 2024, and I wanted to share the take-home points, at least about the most relevant features in this language version. Posting the slides made no sense as they were minimal; all the content was packed in the live demo.\nIn a follow-up post, I plan to address Collection Expressions (done) and maybe \u0026ldquo;type any aliases\u0026rdquo;; this is about Primary Constructors.","keywords":["speaking","csharp","dotnet"],"articleBody":"I wrapped up my C# 12 session at the ABP Dotnet Conference 2024, and I wanted to share the take-home points, at least about the most relevant features in this language version. Posting the slides made no sense as they were minimal; all the content was packed in the live demo.\nIn a follow-up post, I plan to address Collection Expressions (done) and maybe “type any aliases”; this is about Primary Constructors.\nWe can now add a list of parameters to a struct or class declaration. This way, we avoid writing an explicit constructor method, sparing us some boilerplate code.\nWhat I refer to as ‘primary parameters’ are unique in that they are in scope throughout the type definition; this means they can be used anywhere within the type.\npublic readonly struct Distance(double dx, double dy) { public readonly double Magnitude { get; } = Math.Sqrt(dx * dx + dy * dy); public readonly double Direction { get; } = Math.Atan2(dy, dx); public override string ToString() =\u003e $\"{nameof(Magnitude)}: {Magnitude}, {nameof(Direction)}: {Direction}\"; public double Dx { get; } = dx; public double Dy { get; } = dy; } It’s important to note that primary constructor parameters are not class members; therefore, this. cannot be used on them. They can be considered static values, but unlike typical static values, they can also be used in non-static methods, offering a unique advantage (some black magic happens behind the scenes.)\nWe no longer need to define and assign a type-level field; the compiler will do that behind the scenes when needed; if a behind-the-scenes backing field is unnecessary, it won’t be created.\nPrimary constructor parameters don’t become properties and are inaccessible outside the instance. We can create properties to expose their values if needed. Record types are an exception. Constructor parameters become properties with records, and it makes sense because records are generally used as DTOs, whereas we want the option with class and structs.\nSecondary and parameterless constructors can be added to a primary constructor. They must invoke the primary, passing its values along.\npublic Distance() : this(0, 0) { } With primary constructors, we do not have a method body; how do we handle argument validation? One pattern is to perform validation at property assignation. public string AccountID { get; } = ValidAccountNumber(accountID) ? accountID : throw new ArgumentException(\"Invalid account number\", nameof(accountID)); public static bool ValidAccountNumber(string accountID) =\u003e accountID?.Length == 10 \u0026\u0026 accountID.All(c =\u003e char.IsDigit(c)); I like this pattern because it brings property declaration and validation close to each other, making it easier to process and reason about the domain logic. When we perform argument validation in an old-style constructor method, we tend to separate validation and declaration, making it difficult to reconcile the two aspects, especially when we have hundreds of lines between constructor code and property declaration.\nDerived types can have a primary constructor, too; it must invoke the base class’ primary constructor.\npublic class CheckingAccount(string accountID, string owner, decimal overdraftLimit = 0) : BankAccount(accountID, owner) Old-style derived types can still derive from a primary constructor type; a regular constructor will invoke the base primary, as we’ve always been doing.\nRegarding inheritance, we can mix and match primary constructor types with old-style types, making it easy to refactor our libraries to use primary constructors. We know that adopters will have no problem deriving from our refactored types.\nWatch out for “nested captures” of primary parameter values in derived types. If both the derived and the base type capture them, and one (or both) change their captured values, we may end up with non-aligned instance values. Roslyn’s analyzer will raise a warning so we can fix our code or mute the alert with a pragma.\nVisual Studio and Visual Studio code offer built-in support for primary constructors (refactorings, etc.) That’s true for JetBrains Rider or any other IDEs leveraging Roslyn.\nThe primary constructor’s original implementation dates back to C# 6 in 2015. It was publicly available in one of those version previews for a short period. Then, it was taken back to the drawing board, only to resurface with record types in C# 9 (?) and custom types in C# 12.\nAlso see: C# 12 Collection Expressions.\n","wordCount":"697","inLanguage":"en","datePublished":"2024-05-09T18:04:39+02:00","dateModified":"2024-05-09T18:04:39+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/csharp-primary-constructors/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title=newsletter><span>newsletter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C# 12 Primary Constructors</h1><div class=post-meta><span title='2024-05-09 18:04:39 +0200 CEST'>May 9, 2024</span></div></header><div class=post-content><p>I wrapped up my C# 12 session at the <a href=https://abp.io/conference/2024>ABP Dotnet Conference 2024</a>, and I wanted to share the take-home points, at least about the most relevant features in this language version. Posting the slides made no sense as they were minimal; all the content was packed in the live demo.</p><p>In a follow-up post, I plan to address Collection Expressions (<a href=/csharp-collection-expressions>done</a>) and maybe &ldquo;type any aliases&rdquo;; this is about Primary Constructors.</p><ul><li><p>We can now add a list of parameters to a struct or class declaration. This way, we avoid writing an explicit constructor method, sparing us some boilerplate code.</p></li><li><p>What I refer to as &lsquo;primary parameters&rsquo; are unique in that they are in scope throughout the type definition; this means they can be used anywhere within the type.</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=font-weight:700>public</span> <span style=font-weight:700>readonly</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>Distance</span>(<span>double</span> dx, <span>double</span> dy)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=font-weight:700>public</span> <span style=font-weight:700>readonly</span> <span>double</span> Magnitude { <span style=font-weight:700>get</span>; } = Math.Sqrt(dx * dx + dy * dy);
</span></span><span style=display:flex><span>    <span style=font-weight:700>public</span> <span style=font-weight:700>readonly</span> <span>double</span> Direction { <span style=font-weight:700>get</span>; } = Math.Atan2(dy, dx);
</span></span><span style=display:flex><span>    <span style=font-weight:700>public</span> <span style=font-weight:700>override</span> <span>string</span> ToString() =&gt; <span style=font-style:italic>$&#34;{nameof(Magnitude)}: {Magnitude}, {nameof(Direction)}: {Direction}&#34;</span>;
</span></span><span style=display:flex><span>    <span style=font-weight:700>public</span> <span>double</span> Dx { <span style=font-weight:700>get</span>; } = dx;
</span></span><span style=display:flex><span>    <span style=font-weight:700>public</span> <span>double</span> Dy { <span style=font-weight:700>get</span>; } = dy;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>It&rsquo;s important to note that primary constructor parameters are not class members; therefore, <code>this.</code> cannot be used on them. They can be considered static values, but unlike typical static values, they can also be used in non-static methods, offering a unique advantage (some black magic happens behind the scenes.)</p></li><li><p>We no longer need to define and assign a type-level field; the compiler will do that behind the scenes when needed; if a behind-the-scenes backing field is unnecessary, it won&rsquo;t be created.</p></li><li><p>Primary constructor parameters don&rsquo;t become properties and are inaccessible outside the instance. We can create properties to expose their values if needed. Record types are an exception. Constructor parameters become properties with records, and it makes sense because records are generally used as DTOs, whereas we want the option with class and structs.</p></li><li><p>Secondary and parameterless constructors can be added to a primary constructor. They must invoke the primary, passing its values along.</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=font-weight:700>public</span> Distance() : <span style=font-weight:700>this</span>(0, 0) { }
</span></span></code></pre></div><ul><li>With primary constructors, we do not have a method body; how do we handle argument validation? One pattern is to perform validation at property assignation.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=font-weight:700>public</span> <span>string</span> AccountID { <span style=font-weight:700>get</span>; } = ValidAccountNumber(accountID)
</span></span><span style=display:flex><span>    ? accountID
</span></span><span style=display:flex><span>    : <span style=font-weight:700>throw</span> <span style=font-weight:700>new</span> ArgumentException(<span style=font-style:italic>&#34;Invalid account number&#34;</span>, nameof(accountID));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>public</span> <span style=font-weight:700>static</span> <span>bool</span> ValidAccountNumber(<span>string</span> accountID) =&gt; accountID?.Length == 10 &amp;&amp; accountID.All(c =&gt; <span>char</span>.IsDigit(c));
</span></span></code></pre></div><ul><li><p>I like this pattern because it brings property declaration and validation close to each other, making it easier to process and reason about the domain logic. When we perform argument validation in an old-style constructor method, we tend to separate validation and declaration, making it difficult to reconcile the two aspects, especially when we have hundreds of lines between constructor code and property declaration.</p></li><li><p>Derived types can have a primary constructor, too; it must invoke the base class&rsquo; primary constructor.</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=font-weight:700>public</span> <span style=font-weight:700>class</span> <span style=font-weight:700>CheckingAccount</span>(<span>string</span> accountID, <span>string</span> owner, <span>decimal</span> overdraftLimit = 0) : BankAccount(accountID, owner)
</span></span></code></pre></div><ul><li><p>Old-style derived types can still derive from a primary constructor type; a regular constructor will invoke the base primary, as we&rsquo;ve always been doing.</p></li><li><p>Regarding inheritance, we can mix and match primary constructor types with old-style types, making it easy to refactor our libraries to use primary constructors. We know that adopters will have no problem deriving from our refactored types.</p></li><li><p>Watch out for &ldquo;nested captures&rdquo; of primary parameter values in derived types. If both the derived and the base type capture them, and one (or both) change their captured values, we may end up with non-aligned instance values. Roslyn&rsquo;s analyzer will raise a warning so we can fix our code or mute the alert with a pragma.</p></li><li><p>Visual Studio and Visual Studio code offer built-in support for primary constructors (refactorings, etc.) That&rsquo;s true for JetBrains Rider or any other IDEs leveraging Roslyn.</p></li><li><p>The primary constructor&rsquo;s original implementation dates back to C# 6 in 2015. It was publicly available in one of those version previews for a short period. Then, it was taken back to the drawing board, only to resurface with record types in C# 9 (?) and custom types in C# 12.</p></li></ul><p>Also see: <a href=/csharp-collection-expressions/>C# 12 Collection Expressions</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/speaking/>speaking</a></li><li><a href=https://nicolaiarocci.com/tags/csharp/>csharp</a></li><li><a href=https://nicolaiarocci.com/tags/dotnet/>dotnet</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>