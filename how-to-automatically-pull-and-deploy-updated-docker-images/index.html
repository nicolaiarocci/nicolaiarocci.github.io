<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to automatically pull and deploy updated Docker images | Nicola Iarocci</title>
<meta name=keywords content="til,docker"><meta name=description content="We want our test and production stacks to be automatically updated every time something new is pushed to the test or release branch. CI builds the docker image on successful test runs, then stores it in our private registry. But how do you automatically pull and deploy those updated images?
I looked into the Watchtower project, which is interesting. You add Watchtower to the stack, and it will diligently check for new versions of the images used by the containers in the stack, pulling, building and deploying as needed while the stack is up and running."><meta name=author content><link rel=canonical href=https://nicolaiarocci.com/how-to-automatically-pull-and-deploy-updated-docker-images/><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to automatically pull and deploy updated Docker images"><meta property="og:description" content="We want our test and production stacks to be automatically updated every time something new is pushed to the test or release branch. CI builds the docker image on successful test runs, then stores it in our private registry. But how do you automatically pull and deploy those updated images?
I looked into the Watchtower project, which is interesting. You add Watchtower to the stack, and it will diligently check for new versions of the images used by the containers in the stack, pulling, building and deploying as needed while the stack is up and running."><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/how-to-automatically-pull-and-deploy-updated-docker-images/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-11-21T07:05:25+01:00"><meta property="article:modified_time" content="2021-11-21T07:05:25+01:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to automatically pull and deploy updated Docker images"><meta name=twitter:description content="We want our test and production stacks to be automatically updated every time something new is pushed to the test or release branch. CI builds the docker image on successful test runs, then stores it in our private registry. But how do you automatically pull and deploy those updated images?
I looked into the Watchtower project, which is interesting. You add Watchtower to the stack, and it will diligently check for new versions of the images used by the containers in the stack, pulling, building and deploying as needed while the stack is up and running."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":3,"name":"How to automatically pull and deploy updated Docker images","item":"https://nicolaiarocci.com/how-to-automatically-pull-and-deploy-updated-docker-images/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to automatically pull and deploy updated Docker images","name":"How to automatically pull and deploy updated Docker images","description":"We want our test and production stacks to be automatically updated every time something new is pushed to the test or release branch. CI builds the docker image on successful test runs, then stores it in our private registry. But how do you automatically pull and deploy those updated images?\nI looked into the Watchtower project, which is interesting. You add Watchtower to the stack, and it will diligently check for new versions of the images used by the containers in the stack, pulling, building and deploying as needed while the stack is up and running.","keywords":["til","docker"],"articleBody":"We want our test and production stacks to be automatically updated every time something new is pushed to the test or release branch. CI builds the docker image on successful test runs, then stores it in our private registry. But how do you automatically pull and deploy those updated images?\nI looked into the Watchtower project, which is interesting. You add Watchtower to the stack, and it will diligently check for new versions of the images used by the containers in the stack, pulling, building and deploying as needed while the stack is up and running. In my experiments, however, I had little luck in making it talk with our private registry. Also, I’m not too fond of polluting my stack with foreign containers. I want my docker stack to be simple, tidy, clean, and single-tasked.\nI ended up doing something super simple. A cronjob routinely invokes a script that pulls relevant images from our registry. If updated images are downloaded, then the docker stack up command is issued. Finally, a docker image prune -af ensures obsolete images are deleted. For the simplest scenario, where we only need to take care of one image, the script looks like this:\n#!/bin/bash set -e readonly IMAGE=[image] readonly TAG=[tag] out=$(docker pull $IMAGE:$TAG) if [[ $out != *\"up to date\"* ]]; then echo \"an updated image has been donwloaded for '$IMAGE:$TAG'\" # we actually launch a script here: docker stack up -c stack.yml mystack --with-registry-auth docker image prune -af else echo \"no updates available for '$IMAGE:$TAG'\" fi I expected docker pull to return 1 on successful pulls; it turns out it always returns 0, so I’m checking its output for confirmation (I got the hint here).\nYou might be wondering why we don’t directly execute docker stack up in our cronjob. It updates the stack resolving new images by default. The problem is that, in our experience, it also briefly stops the services. Not an issue if you run this command sporadically. We want our stacks refreshed minutes after the initial developer push, though, so the cronjob runs frequently. With our pre-fetch approach, actual deployment only happens when an updated image has been found and downloaded.\nNow, when I push to, say, test branch, I have the updated services up and running a minute later, without me doing anything on the docker or server-side of things. Mission accomplished, I guess, but I am sure there are other, better ways around this problem. If you happen to know one, please let me know about it (keep in mind, we don’t use alternative orchestrators, just the built-in ‘swarm’ thing.)\nSubscribe to the newsletter, the RSS feed, or follow @nicolaiarocci on Twitter\n","wordCount":"445","inLanguage":"en","datePublished":"2021-11-21T07:05:25+01:00","dateModified":"2021-11-21T07:05:25+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/how-to-automatically-pull-and-deploy-updated-docker-images/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Home (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=conferences><span>conferences</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">How to automatically pull and deploy updated Docker images</h1><div class=post-meta><span title='2021-11-21 07:05:25 +0100 CET'>November 21, 2021</span></div></header><div class=post-content><p>We want our test and production stacks to be automatically updated every time
something new is pushed to the <code>test</code> or <code>release</code> branch. CI builds the docker
image on successful test runs, then stores it in our private registry. But how
do you automatically pull and deploy those updated images?</p><p>I looked into the <a href=https://containrrr.dev/watchtower/>Watchtower</a> project, which is interesting. You add
Watchtower to the stack, and it will diligently check for new versions of the
images used by the containers in the stack, pulling, building and deploying as
needed while the stack is up and running. In my experiments, however, I had
<a href=https://github.com/containrrr/watchtower/issues/1113>little luck</a> in making it talk with our private registry. Also, I&rsquo;m not too
fond of polluting my stack with foreign containers. I want my docker stack to
be simple, tidy, clean, and single-tasked.</p><p>I ended up doing something super simple. A cronjob routinely invokes a script
that pulls relevant images from our registry. If updated images are downloaded,
then the <code>docker stack up</code> command is issued. Finally, a <code>docker image prune -af</code> ensures obsolete images are deleted. For the simplest scenario, where we
only need to take care of one image, the script looks like this:</p><pre><code>#!/bin/bash
set -e

readonly IMAGE=[image]
readonly TAG=[tag]

out=$(docker pull $IMAGE:$TAG)

if [[ $out != *&quot;up to date&quot;* ]]; then
    echo &quot;an updated image has been donwloaded for '$IMAGE:$TAG'&quot;
    # we actually launch a script here:
    docker stack up -c stack.yml mystack --with-registry-auth
    docker image prune -af
else
    echo &quot;no updates available for '$IMAGE:$TAG'&quot;
fi
</code></pre><p>I expected <code>docker pull</code> to return <code>1</code> on successful pulls; it turns out it
always returns <code>0</code>, so I&rsquo;m checking its output for confirmation (I got the hint
<a href=https://stackoverflow.com/a/51628017/323269>here</a>).</p><p>You might be wondering why we don&rsquo;t directly execute <code>docker stack up</code> in our
cronjob. It updates the stack resolving new images by default. The problem is
that, in our experience, it also briefly stops the services. Not an issue if
you run this command sporadically. We want our stacks refreshed minutes after
the initial developer push, though, so the cronjob runs frequently. With our
pre-fetch approach, actual deployment only happens when an updated image has
been found and downloaded.</p><p>Now, when I push to, say, <code>test</code> branch, I have the updated services up and
running a minute later, without me doing anything on the docker or server-side
of things. Mission accomplished, I guess, but I am sure there are other, better
ways around this problem. If you happen to know one, please let me know about
it (keep in mind, we don&rsquo;t use alternative orchestrators, just the built-in
&lsquo;swarm&rsquo; thing.)</p><p><em>Subscribe to the <a href=https://nicolaiarocci.substack.com>newsletter</a>, the <a href=https://nicolaiarocci.com/index.xml>RSS feed</a>, or follow @<a href=http://twitter.com/nicolaiarocci>nicolaiarocci</a> on Twitter</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/til/>til</a></li><li><a href=https://nicolaiarocci.com/tags/docker/>docker</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>