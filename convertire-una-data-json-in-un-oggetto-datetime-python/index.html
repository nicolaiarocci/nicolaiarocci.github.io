<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Convertire una data JSON in un oggetto datetime Python | Nicola Iarocci</title>
<meta name=keywords content="datetime,json,programmazione,python"><meta name=description content="Abbiamo una stringa JSON che contiene una data:
fonte = '{&#34;ragione_sociale&#34;: &#34;CIR 2000&#34;, &#34;aggiornato_il&#34;: &#34;Wed, 06 Jun 2012 14:19:53 UTC&#34;}' Vediamo che succede se la convertiamo in un dizionario Python:
import simplejson as json json.loads(fonte) {'aggiornato_il': 'Wed, 06 Jun 2012 14:19:53 UTC ', 'ragione_sociale': 'CIR 2000'} Facile, vero? C’è però un piccolo problema: aggiornato_il è ancora una stringa mentre a noi, per poterlo elaborare comodamente, serve un campo datetime.datetime. Come mai il pur potente modulo simplejson non converte correttamente la nostra data?"><meta name=author content="Nicola Iarocci"><link rel=canonical href=https://nicolaiarocci.com/convertire-una-data-json-in-un-oggetto-datetime-python/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Convertire una data JSON in un oggetto datetime Python"><meta property="og:description" content="Abbiamo una stringa JSON che contiene una data:
fonte = '{&#34;ragione_sociale&#34;: &#34;CIR 2000&#34;, &#34;aggiornato_il&#34;: &#34;Wed, 06 Jun 2012 14:19:53 UTC&#34;}' Vediamo che succede se la convertiamo in un dizionario Python:
import simplejson as json json.loads(fonte) {'aggiornato_il': 'Wed, 06 Jun 2012 14:19:53 UTC ', 'ragione_sociale': 'CIR 2000'} Facile, vero? C’è però un piccolo problema: aggiornato_il è ancora una stringa mentre a noi, per poterlo elaborare comodamente, serve un campo datetime.datetime. Come mai il pur potente modulo simplejson non converte correttamente la nostra data?"><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/convertire-una-data-json-in-un-oggetto-datetime-python/"><meta property="article:section" content="post"><meta property="article:published_time" content="2012-06-07T00:00:00+00:00"><meta property="article:modified_time" content="2012-06-07T00:00:00+00:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="Convertire una data JSON in un oggetto datetime Python"><meta name=twitter:description content="Abbiamo una stringa JSON che contiene una data:
fonte = '{&#34;ragione_sociale&#34;: &#34;CIR 2000&#34;, &#34;aggiornato_il&#34;: &#34;Wed, 06 Jun 2012 14:19:53 UTC&#34;}' Vediamo che succede se la convertiamo in un dizionario Python:
import simplejson as json json.loads(fonte) {'aggiornato_il': 'Wed, 06 Jun 2012 14:19:53 UTC ', 'ragione_sociale': 'CIR 2000'} Facile, vero? C’è però un piccolo problema: aggiornato_il è ancora una stringa mentre a noi, per poterlo elaborare comodamente, serve un campo datetime.datetime. Come mai il pur potente modulo simplejson non converte correttamente la nostra data?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"Convertire una data JSON in un oggetto datetime Python","item":"https://nicolaiarocci.com/convertire-una-data-json-in-un-oggetto-datetime-python/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Convertire una data JSON in un oggetto datetime Python","name":"Convertire una data JSON in un oggetto datetime Python","description":"Abbiamo una stringa JSON che contiene una data:\nfonte = '{\u0026quot;ragione_sociale\u0026quot;: \u0026quot;CIR 2000\u0026quot;, \u0026quot;aggiornato_il\u0026quot;: \u0026quot;Wed, 06 Jun 2012 14:19:53 UTC\u0026quot;}' Vediamo che succede se la convertiamo in un dizionario Python:\nimport simplejson as json json.loads(fonte) {'aggiornato_il': 'Wed, 06 Jun 2012 14:19:53 UTC ', 'ragione_sociale': 'CIR 2000'} Facile, vero? C’è però un piccolo problema: aggiornato_il è ancora una stringa mentre a noi, per poterlo elaborare comodamente, serve un campo datetime.datetime. Come mai il pur potente modulo simplejson non converte correttamente la nostra data?","keywords":["datetime","json","programmazione","python"],"articleBody":"Abbiamo una stringa JSON che contiene una data:\nfonte = '{\"ragione_sociale\": \"CIR 2000\", \"aggiornato_il\": \"Wed, 06 Jun 2012 14:19:53 UTC\"}' Vediamo che succede se la convertiamo in un dizionario Python:\nimport simplejson as json json.loads(fonte) {'aggiornato_il': 'Wed, 06 Jun 2012 14:19:53 UTC ', 'ragione_sociale': 'CIR 2000'} Facile, vero? C’è però un piccolo problema: aggiornato_il è ancora una stringa mentre a noi, per poterlo elaborare comodamente, serve un campo datetime.datetime. Come mai il pur potente modulo simplejson non converte correttamente la nostra data?\nIl problema Il fatto è che il JSON originale non fa nulla per informarci del fatto che il campo aggiornato_il esprime in realtà una data. La radice del problema sta nello standard JSON il quale non contempla la dichiarazione esplicita dei tipi di dati. In effetti la stessa questione si pone nella conversione di un numero non intero: va considerato un float, oppure un decimal? In quest’ultimo caso simplejson ci viene in aiuto con il parametro parse_float:\nimport simplejson as json json.loads('1.1', parse_float=decimal.Decimal) Decimal('1.1') Purtroppo, per il motivo visto prima, non esiste un equivalente per le date.\nLa soluzione classica In questi casi la prassi comune è rendere esplicito, già all’interno della stringa JSON, il formato del campo. Qualcosa del genere:\n{\"aggiornato_il\": \"$date: Wed, 06 Jun 2012 14:19:53 UTC\"} Così facendo possiamo in seguito manipolare il dizionario restituito dal metodo loads: intercettare la direttiva $date e sostituire finalmente la stringa con una data. Una soluzione più raffinata è quella di sfruttare l’opzione object_hook che consente di invocare una nostra funzione ad ogni chiamata del metodo loads.\nLa mia soluzione Nel mio caso il provider JSON è esterno, e non desidero obbligarlo a pre-processare le stringhe JSON inserendo clausole $date arbitrarie solo per soddisfare le esigenze della mia applicazione. Sfruttando l’opzione object_hook già accennata ho ottenuto una soluzione del tutto trasparente:\nfonte = '{\"aggiornato_il\": \"Thu, 1 Mar 2012 10:00:49 UTC\"}' dct = json.loads(fonte, object_hook=datetime_parser) dct {u'aggiornato_il': datetime.datetime(2012, 3, 1, 10, 0, 49)} def datetime_parser(dct): for k, v in dct.items(): if isinstance(v, basestring) and re.search(\" UTC\", v): try: dct[k] = datetime.datetime.strptime(v, DATE_FORMAT) except: pass return dct La funzione datetime_parser esamina gli elementi della stringa JSON. In caso di corrispondenza alla espressione regolare indicata in re.search tentiamo una conversione diretta al formato datetime. Data la specificità della espressione regolare la conversione dovrebbe avere successo. Il blocco try... except ci permette di ignorare un eventuale errore: in questo caso infatti presumiamo che si tratti di una stringa vera e propria e non, malgrado la somiglianza, di una data. L’unico vincolo imposto al provider JSON è l’adozione di un formato standard per rappresentare le date. Nel mio caso è il seguente:\nDATE_FORMAT = '%a, %d %b %Y %H:%M:%S UTC' Per approfondimenti vi consiglio:\nJSON econdoer and decoder Introduzione alle Regular Expression Per completezza c’è da aggiungere che l’adozione di un json schema consentirebbe la specifica dei tipi di dati JSON. Quest’ultima soluzione però, data la sua complessità, non è applicabile nel mio e in molti altri casi.\nPS: ne ho scritto anche su Stack Overflow.\n","wordCount":"502","inLanguage":"en","datePublished":"2012-06-07T00:00:00Z","dateModified":"2012-06-07T00:00:00Z","author":{"@type":"Person","name":"Nicola Iarocci"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/convertire-una-data-json-in-un-oggetto-datetime-python/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title="mailing list"><span>mailing list</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Convertire una data JSON in un oggetto datetime Python</h1><div class=post-meta><span title='2012-06-07 00:00:00 +0000 UTC'>June 7, 2012</span>&nbsp;·&nbsp;Nicola Iarocci</div></header><div class=post-content><p>Abbiamo una stringa JSON che contiene una data:</p><pre><code>fonte = '{&quot;ragione_sociale&quot;: &quot;CIR 2000&quot;, &quot;aggiornato_il&quot;: &quot;Wed, 06 Jun 2012 14:19:53 UTC&quot;}'
</code></pre><p>Vediamo che succede se la convertiamo in un dizionario Python:</p><pre><code>import simplejson as json

json.loads(fonte)
{'aggiornato_il': 'Wed, 06 Jun 2012 14:19:53 UTC ', 'ragione_sociale': 'CIR 2000'}
</code></pre><p>Facile, vero? C’è però un piccolo problema: <code>aggiornato_il</code> è ancora una stringa mentre a noi, per poterlo elaborare comodamente, serve un campo <code>datetime.datetime</code>. Come mai il pur potente modulo <code>simplejson</code> non converte correttamente la nostra data?</p><h2 id=il-problema>Il problema<a hidden class=anchor aria-hidden=true href=#il-problema>#</a></h2><p>Il fatto è che il JSON originale non fa nulla per informarci del fatto che il campo <code>aggiornato_il</code> esprime in realtà una data. La radice del problema sta nello standard JSON il quale non contempla la dichiarazione esplicita dei tipi di dati. In effetti la stessa questione si pone nella conversione di un numero non intero: va considerato un float, oppure un decimal? In quest’ultimo caso <code>simplejson</code> ci viene in aiuto con il parametro parse_float:</p><pre><code>import simplejson as json

json.loads('1.1', parse_float=decimal.Decimal)
Decimal('1.1')
</code></pre><p>Purtroppo, per il motivo visto prima, non esiste un equivalente per le date.</p><h2 id=la-soluzione-classica>La soluzione classica<a hidden class=anchor aria-hidden=true href=#la-soluzione-classica>#</a></h2><p>In questi casi la prassi comune è rendere esplicito, già all’interno della stringa JSON, il formato del campo. Qualcosa del genere:</p><pre><code>{&quot;aggiornato_il&quot;: &quot;$date: Wed, 06 Jun 2012 14:19:53 UTC&quot;}
</code></pre><p>Così facendo possiamo in seguito manipolare il dizionario restituito dal metodo <code>loads</code>: intercettare la direttiva <code>$date</code> e sostituire finalmente la stringa con una data. Una soluzione più raffinata è quella di sfruttare l’opzione <code>object_hook</code> che consente di invocare una nostra funzione ad ogni chiamata del metodo <code>loads</code>.</p><h2 id=la-mia-soluzione>La mia soluzione<a hidden class=anchor aria-hidden=true href=#la-mia-soluzione>#</a></h2><p>Nel mio caso il provider JSON è esterno, e non desidero obbligarlo a pre-processare le stringhe JSON inserendo clausole $date arbitrarie solo per soddisfare le esigenze della mia applicazione. Sfruttando l’opzione object_hook già accennata ho ottenuto una soluzione del tutto trasparente:</p><pre><code>fonte = '{&quot;aggiornato_il&quot;: &quot;Thu, 1 Mar 2012 10:00:49 UTC&quot;}'
dct = json.loads(fonte, object_hook=datetime_parser)
dct
{u'aggiornato_il': datetime.datetime(2012, 3, 1, 10, 0, 49)}


def datetime_parser(dct):
    for k, v in dct.items():
        if isinstance(v, basestring) and re.search(&quot; UTC&quot;, v):
            try:
                dct[k] = datetime.datetime.strptime(v, DATE_FORMAT)
            except:
                pass
    return dct
</code></pre><p>La funzione <code>datetime_parser</code> esamina gli elementi della stringa JSON. In caso di corrispondenza alla espressione regolare indicata in <code>re.search</code> tentiamo una conversione diretta al formato <code>datetime</code>. Data la specificità della espressione regolare la conversione dovrebbe avere successo. Il blocco <code>try... except</code> ci permette di ignorare un eventuale errore: in questo caso infatti presumiamo che si tratti di una stringa vera e propria e non, malgrado la somiglianza, di una data. L’unico vincolo imposto al provider JSON è l’adozione di un formato standard per rappresentare le date. Nel mio caso è il seguente:</p><pre><code>DATE_FORMAT = '%a, %d %b %Y %H:%M:%S UTC'
</code></pre><p>Per approfondimenti vi consiglio:</p><ul><li>JSON econdoer and decoder</li><li><a href=http://nicolaiarocci.com/introduzione-alle-regular-expression-prima-parte/ title="Introduzione alle Regular Expression">Introduzione alle Regular Expression</a></li></ul><p>Per completezza c’è da aggiungere che l’adozione di un json schema consentirebbe la specifica dei tipi di dati JSON. Quest’ultima soluzione però, data la sua complessità, non è applicabile nel mio e in molti altri casi.</p><p>PS: ne ho scritto anche su Stack Overflow.</p><i>Join the <a href=https://buttondown.email/nicolaiarocci>mailing list</a> or subscribe to the <a href=/index.xml>RSS
feed</a>. Follow me on <a href=https://fosstodon.org/@nicola>Mastodon</a> or <a href=https://twitter.com/nicolaiarocci>X</a>.</div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/datetime/>datetime</a></li><li><a href=https://nicolaiarocci.com/tags/json/>json</a></li><li><a href=https://nicolaiarocci.com/tags/programmazione/>programmazione</a></li><li><a href=https://nicolaiarocci.com/tags/python/>python</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>