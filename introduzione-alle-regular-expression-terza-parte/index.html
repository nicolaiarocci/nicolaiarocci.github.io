<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introduzione alle Regular Expression – Terza Parte | Nicola Iarocci</title>
<meta name=keywords content="programmazione,regex,regular expression,tutorial"><meta name=description content="Benvenuto alla terza e ultima parte della nostra Introduzione alle Regular Expression. Concluso il capitolo sarai in grado di affrontare la maggior parte dei problemi di ricerca nel testo. Se ancora non l&rsquo;hai fatto ti consiglio di leggere la Prima Parte e la Seconda Parte. Ricorda che puoi usare la pagina di prova per testare le query della guida.
Avidità Il problema della avidità degli operatori regex diventa evidente quando si comincia a lavorare su ricerche avanzate."><meta name=author content="Nicola Iarocci"><link rel=canonical href=https://nicolaiarocci.com/introduzione-alle-regular-expression-terza-parte/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Introduzione alle Regular Expression – Terza Parte"><meta property="og:description" content="Benvenuto alla terza e ultima parte della nostra Introduzione alle Regular Expression. Concluso il capitolo sarai in grado di affrontare la maggior parte dei problemi di ricerca nel testo. Se ancora non l&rsquo;hai fatto ti consiglio di leggere la Prima Parte e la Seconda Parte. Ricorda che puoi usare la pagina di prova per testare le query della guida.
Avidità Il problema della avidità degli operatori regex diventa evidente quando si comincia a lavorare su ricerche avanzate."><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/introduzione-alle-regular-expression-terza-parte/"><meta property="article:section" content="post"><meta property="article:published_time" content="2011-03-03T00:00:00+00:00"><meta property="article:modified_time" content="2011-03-03T00:00:00+00:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduzione alle Regular Expression – Terza Parte"><meta name=twitter:description content="Benvenuto alla terza e ultima parte della nostra Introduzione alle Regular Expression. Concluso il capitolo sarai in grado di affrontare la maggior parte dei problemi di ricerca nel testo. Se ancora non l&rsquo;hai fatto ti consiglio di leggere la Prima Parte e la Seconda Parte. Ricorda che puoi usare la pagina di prova per testare le query della guida.
Avidità Il problema della avidità degli operatori regex diventa evidente quando si comincia a lavorare su ricerche avanzate."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"Introduzione alle Regular Expression – Terza Parte","item":"https://nicolaiarocci.com/introduzione-alle-regular-expression-terza-parte/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introduzione alle Regular Expression – Terza Parte","name":"Introduzione alle Regular Expression – Terza Parte","description":"Benvenuto alla terza e ultima parte della nostra Introduzione alle Regular Expression. Concluso il capitolo sarai in grado di affrontare la maggior parte dei problemi di ricerca nel testo. Se ancora non l\u0026rsquo;hai fatto ti consiglio di leggere la Prima Parte e la Seconda Parte. Ricorda che puoi usare la pagina di prova per testare le query della guida.\nAvidità Il problema della avidità degli operatori regex diventa evidente quando si comincia a lavorare su ricerche avanzate.","keywords":["programmazione","regex","regular expression","tutorial"],"articleBody":"Benvenuto alla terza e ultima parte della nostra Introduzione alle Regular Expression. Concluso il capitolo sarai in grado di affrontare la maggior parte dei problemi di ricerca nel testo. Se ancora non l’hai fatto ti consiglio di leggere la Prima Parte e la Seconda Parte. Ricorda che puoi usare la pagina di prova per testare le query della guida.\nAvidità Il problema della avidità degli operatori regex diventa evidente quando si comincia a lavorare su ricerche avanzate. Un caso tipico è il parsing di file XML o HTML.\nquesto è un paragrafo\nSupponiamo di voler trovare tutti i tag usati.\n\u003c.*\u003e # cerca tutti i tag Il risultato della query non è quello che ci si potrebbe aspettare. L’operatore * è avido, ovvero cerca di catturare più caratteri possibili. Una volta trovato il primo \u003c prosegue avidamente selezionando tutto fino all’ultimo \u003e. In questo caso vogliamo che si fermi al primo \u003e, non all’ultimo. E’ questa una distinzione importante, da comprendere a fondo. Possiamo disattivare il comportamento avido aggiungendo il carattere?\n\u003c.*?\u003e # ora otteniamo quel che vogliamo (niente avidità) Se desideriamo usare l’operatore + (1 o più) al posto del * (zero o più), la nostra query diventa \u003c.+?\u003e.\nConfini Nella seconda parte del nostro tutorial abbiamo convalidato un numero telefonico nel formato 555-12345678\n555-\\d{8} # 555- seguito da 8 cifre Anche se tecnicamente corretta questa query non è perfetta. Se la testiamo con queste stringhe:\ntestoDavanti 555-12345678 555-12345678 il mio telefono scopriamo che vengono accettate perché la regola 555-\\d{8} è ancora valida. In realtà noi desideriamo accettare il solo il numero telefonico, niente altro. La soluzione richiede l’uso degli operatori di confine:\n^555-\\d{8}$ I confini sono caratteri speciali perché non occupano spazio. Sono dei segnaposto che servono a delimitare il testo da cercare. Dopo l’inizio (^) deve esserci il nostro numero di telefono; prima della fine ($) deve esserci il nostro numero di telefono.\nsignificato Inizio del testo. Sfortunatamente gli inventori di regex hanno scelto lo stesso carattere usato per la negazione. E\u0026#8217; importante riconoscerne il significato in base al contesto. Quando non è compreso tra [ e ] il carattere ^ è un confine e indica l\u0026#8217;inizio del testo. fine del testo Quindi\na # trova qualunque a ^a # trova solo il testo che comincia per a a$ # trova solo il testo che finisce per a C’è un altro confine, quello di parola (\\b). Vediamo un esempio. Vogliamo cercare le parole “for” e “she” nella nostra pagina di test.\n(for|she) # trova for e she Non va male. Trova tutte le occorrenze di “she” e “for”, tuttavia viene selezionata anche la parola “before”. Non è il comportamento desiderato. Potremmo tentare cercando solo le occorrenze precedute e succedute da uno spazio.\n[ ](for|she)[ ] # cerca for o she Va meglio. Non seleziona più before. Abbiamo però un nuovo problema. Nel testo c’è la frase “for she had plenty of time”. La nostra regex non ha individuato la parola “she” contenuta nella frase. Per quale motivo?\nfor she had plenty of time Con il “for” iniziale abbiamo già rintracciato lo spazio che precede “she”, che quindi viene escluso. Sono queste le situazioni un cui un confine di parola può risolvere il problema.\n\\b(for|she)\\b # trova she oppure for Il confine \\b definisce dove la parola comincia e finisce, proprio come succede con i confini visti prima. Abbiamo detto prima che i “confini non occupano spazio”. Nell’esempio qui sopra cerchiamo esattamente “for” o “she”. Non cerchiamo la stringa \\b e questa non occupa alcuno spazio durante la ricerca, a differenza di quel che è successo quando abbiamo tentato di usare la [cornice]. E’ un dettaglio importate perché con tutti gli altri operatori regex ciò che è nella query “occupa spazio” e non può essere trovato di nuovo.\nIl Finale: Ricerca e Sostituzione Ce l’hai fatta! Sei arrivato in fondo. Congratulazioni. Il meglio arriva ora. Ricerca e sostituzione è senz’altro il mio argomento preferito. Qui la pagina di test non ci può aiutare, occorre qualche tipo di editor oppure una IDE (Eclipse/Notepad++/Wordpad).\nSupponiamo di avere un file composto da 100 righe come queste\n31-01-10_backup32 24-01-10_backup1 24-02-10_backup_mona 11-03-09_backup_lisa Vogliamo correggere le date portandole dal formato europeo a quello americano (da gg-mm-aa a mm-gg-aaaa).\n\\d{2}-\\d{2}-\\d{2}_backup.* // trova le nostre righe Per ogni riga desideriamo sostituire aree specifiche quindi ricorriamo all’operatore di raggruppamento già visto nella seconda parte di questa guida.\n(\\d{2})-(\\d{2})-(\\d{2})_backup(.*) // ci siamo A questo punto tutto quel che dobbiamo fare è sostituire le righe trovate con\n{Gruppo2}–{Gruppo1}-20{Gruppo3}_backup{Gruppo4}\nIl che si traduce nella seguente espressione di sostituzione\n\\2-\\1-20\\3_backup\\4 Facile no? Niente più lavori ripetitivi. La mia regola è: se un testo richiede la modifica di più di cinque righe è giunta l’ora di ricorrere alle regex. Potrebbe sembrare una esagerazione. Eppure un programmatore dovrebbe rifiutarsi per principio di ripetere manualmente un lavoro che può essere automatizzato.\nBuona fortuna.\nQuesto articolo è una traduzione autorizzata di Regex Primer: Part 3. Ringrazio l’autore per il permesso accordatomi.\n","wordCount":"834","inLanguage":"en","datePublished":"2011-03-03T00:00:00Z","dateModified":"2011-03-03T00:00:00Z","author":{"@type":"Person","name":"Nicola Iarocci"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/introduzione-alle-regular-expression-terza-parte/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title="mailing list"><span>mailing list</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Introduzione alle Regular Expression – Terza Parte</h1><div class=post-meta><span title='2011-03-03 00:00:00 +0000 UTC'>March 3, 2011</span>&nbsp;·&nbsp;Nicola Iarocci</div></header><div class=post-content><p>Benvenuto alla terza e ultima parte della nostra <em>Introduzione alle Regular
Expression</em>. Concluso il capitolo sarai  in grado di affrontare la maggior
parte dei problemi di ricerca nel testo. Se ancora non l&rsquo;hai fatto ti
consiglio di leggere la <a href=http://nicolaiarocci.com/introduzione-alle-regular-expression-prima-parte/>Prima Parte</a> e la <a href=http://nicolaiarocci.com/introduzione-alle-regular-expression-seconda-parte/>Seconda Parte</a>. Ricorda che
puoi usare la pagina di
prova per testare le query della guida.</p><h2 id=avidità>Avidità<a hidden class=anchor aria-hidden=true href=#avidità>#</a></h2><p>Il problema della avidità degli operatori regex diventa evidente quando si
comincia a lavorare su ricerche avanzate. Un caso tipico è il parsing di file
XML o HTML.</p><pre><code>&lt;p&gt;questo è un &lt;b&gt;paragrafo&lt;/b&gt;&lt;/p&gt;
</code></pre><p>Supponiamo di voler trovare tutti i tag usati.</p><pre><code>&lt;.*&gt; # cerca tutti i tag
</code></pre><p>Il risultato della query non è quello che ci si potrebbe aspettare.
L&rsquo;operatore <code>*</code> è <em>avido</em>, ovvero cerca di catturare più caratteri
possibili. Una volta trovato il primo <code>&lt;</code> prosegue avidamente selezionando tutto
fino all&rsquo;ultimo <code>></code>. In questo caso vogliamo che si fermi al primo <code>></code>, non
all&rsquo;ultimo. E&rsquo; questa una distinzione importante, da comprendere
a fondo. Possiamo disattivare il comportamento avido aggiungendo il carattere?</p><pre><code>&lt;.*?&gt; # ora otteniamo quel che vogliamo (niente avidità)
</code></pre><p>Se desideriamo usare l&rsquo;operatore <code>+</code> (1 o più) al posto del <code>*</code> (zero o più),
la nostra query diventa <code>&lt;.+?></code>.</p><h2 id=confini>Confini<a hidden class=anchor aria-hidden=true href=#confini>#</a></h2><p>Nella <a href=http://nicolaiarocci.com/introduzione-alle-regular-expression-seconda-parte/>seconda parte</a> del nostro tutorial abbiamo convalidato un numero
telefonico nel formato 555-12345678</p><pre><code>555-\d{8}   # 555- seguito da 8 cifre
</code></pre><p>Anche se tecnicamente corretta questa query non è perfetta. Se la testiamo con
queste stringhe:</p><pre><code>testoDavanti 555-12345678
555-12345678 il mio telefono
</code></pre><p>scopriamo che vengono accettate perché la regola <code>555-\d{8}</code> è ancora valida.
In realtà noi desideriamo accettare il solo il numero telefonico, niente
altro. La soluzione richiede l&rsquo;uso degli operatori di confine:</p><pre><code>^555-\d{8}$
</code></pre><p>I confini sono caratteri speciali perché non occupano spazio. Sono dei
segnaposto che servono a delimitare il testo da cercare. Dopo l&rsquo;inizio
<code>(^)</code> deve esserci il nostro numero di telefono; prima della fine <code>($)</code> deve
esserci il nostro numero di telefono.</p><pre><code>&lt;th&gt;
  significato
&lt;/th&gt;
</code></pre><pre><code>&lt;td style=&quot;vertical-align: top;&quot;&gt;
  Inizio del testo. Sfortunatamente gli inventori di regex hanno scelto lo stesso carattere usato per la negazione. E&amp;#8217; importante riconoscerne il significato in base al contesto. Quando non è compreso tra [ e ] il carattere ^ è un confine e indica l&amp;#8217;inizio del testo.
&lt;/td&gt;
</code></pre><pre><code>&lt;td&gt;
  fine del testo
&lt;/td&gt;
</code></pre><p>Quindi</p><pre><code>a   #  trova qualunque a
^a  #  trova solo il testo che comincia per a
a$  #  trova solo il testo che finisce per a
</code></pre><p>C&rsquo;è un altro confine, quello di parola <code>(\b)</code>. Vediamo un esempio. Vogliamo
cercare le parole &ldquo;for&rdquo; e &ldquo;she&rdquo; nella nostra pagina di test.</p><pre><code>(for|she)  # trova for e she
</code></pre><p>Non va male. Trova tutte le occorrenze di &ldquo;she&rdquo; e &ldquo;for&rdquo;, tuttavia viene
selezionata anche la parola &ldquo;before&rdquo;. Non è il comportamento desiderato.
Potremmo tentare cercando solo le occorrenze precedute e succedute da uno
spazio.</p><pre><code>[ ](for|she)[ ]  # cerca for o she
</code></pre><p>Va meglio. Non seleziona più before. Abbiamo però un nuovo problema. Nel testo
c&rsquo;è la frase &ldquo;for she had plenty of time&rdquo;. La nostra regex non ha individuato
la parola &ldquo;she&rdquo; contenuta nella frase. Per quale motivo?</p><pre><code>for she had plenty of time
</code></pre><p>Con il &ldquo;for&rdquo; iniziale abbiamo già rintracciato lo spazio che precede &ldquo;she&rdquo;, che
quindi viene escluso. Sono queste le situazioni un cui un confine di parola può
risolvere il problema.</p><pre><code>\b(for|she)\b  # trova she oppure for
</code></pre><p>Il confine <code>\b</code> definisce dove la parola comincia e finisce, proprio come
succede con i confini visti prima. Abbiamo detto prima che i &ldquo;confini non
occupano spazio&rdquo;. Nell&rsquo;esempio qui sopra cerchiamo esattamente
&ldquo;for&rdquo; o &ldquo;she&rdquo;. Non cerchiamo la stringa <code>\b</code> e questa non occupa alcuno spazio
durante la ricerca, a differenza di quel che è successo quando abbiamo tentato
di usare la <code>[cornice]</code>. E&rsquo; un dettaglio importate perché con tutti gli
altri operatori regex ciò che è nella query &ldquo;occupa spazio&rdquo; e non
può essere trovato <em>di nuovo</em>.</p><h2 id=il-finale-ricerca-e-sostituzione>Il Finale: Ricerca e Sostituzione<a hidden class=anchor aria-hidden=true href=#il-finale-ricerca-e-sostituzione>#</a></h2><p>Ce l&rsquo;hai fatta! Sei arrivato in fondo. Congratulazioni. Il meglio arriva ora.
Ricerca e sostituzione è senz&rsquo;altro il mio argomento preferito. Qui la pagina
di test non ci può aiutare, occorre qualche tipo di editor oppure una IDE
(Eclipse/Notepad++/Wordpad).</p><p>Supponiamo di avere un file composto da 100 righe come queste</p><pre><code>31-01-10_backup32
24-01-10_backup1
24-02-10_backup_mona
11-03-09_backup_lisa
</code></pre><p>Vogliamo correggere le date portandole dal formato europeo a quello americano
(da <code>gg-mm-aa</code> a <code>mm-gg-aaaa</code>).</p><pre><code>\d{2}-\d{2}-\d{2}_backup.*  // trova le nostre righe
</code></pre><p>Per ogni riga desideriamo sostituire aree specifiche quindi ricorriamo
all&rsquo;operatore di raggruppamento già visto nella <a href=http://nicolaiarocci.com/introduzione-alle-regular-expression-seconda-parte/>seconda parte</a> di
questa guida.</p><pre><code>(\d{2})-(\d{2})-(\d{2})_backup(.*)  // ci siamo
</code></pre><p>A questo punto tutto quel che dobbiamo fare è sostituire le righe trovate con</p><p>{Gruppo2}–{Gruppo1}-20{Gruppo3}_backup{Gruppo4}</p><p>Il che si traduce nella seguente espressione di sostituzione</p><pre><code>\2-\1-20\3_backup\4
</code></pre><p>Facile no? Niente più lavori ripetitivi. La mia regola è: se un testo richiede
la modifica di più di cinque righe è giunta l&rsquo;ora di ricorrere alle
regex. Potrebbe sembrare una esagerazione. Eppure un programmatore dovrebbe
rifiutarsi per principio di ripetere manualmente un lavoro che può essere
automatizzato.</p><p>Buona fortuna.</p><p>Questo articolo è una traduzione autorizzata di <a href=http://www.agillo.net/regex-primer-part-3/>Regex Primer: Part 3</a>.
Ringrazio l&rsquo;autore per il permesso accordatomi.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/programmazione/>programmazione</a></li><li><a href=https://nicolaiarocci.com/tags/regex/>regex</a></li><li><a href=https://nicolaiarocci.com/tags/regular-expression/>regular expression</a></li><li><a href=https://nicolaiarocci.com/tags/tutorial/>tutorial</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>