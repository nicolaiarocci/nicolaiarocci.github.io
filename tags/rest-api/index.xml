<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>rest api on Nicola Iarocci</title>
    <link>https://nicolaiarocci.com/tags/rest-api/</link>
    <description>Recent content in rest api on Nicola Iarocci</description>
    <generator>Hugo -- 0.121.1</generator>
    <language>en</language>
    <copyright>Produced / Written / Maintained by Nicola Iarocci since 2010</copyright>
    <lastBuildDate>Fri, 16 Oct 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://nicolaiarocci.com/tags/rest-api/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My talk at Percona Live 2015</title>
      <link>https://nicolaiarocci.com/my-talk-at-percona-live-2015/</link>
      <pubDate>Fri, 16 Oct 2015 00:00:00 +0000</pubDate>
      <guid>https://nicolaiarocci.com/my-talk-at-percona-live-2015/</guid>
      <description>The slides of my talk at Percona Live 2015 (Amsterdam) are online. It was titled “MongoDB and REST APIs a Match Made in Heaven” and it was meant as an introduction to Mongo, REST principles and the Eve python framework.
Overall it has been a pleasant experience, although I found that splitting 300 attendees through seven concurrent tracks ultimately led to too much fragmentation. People often found themselves with 2-3 interesting talks all happening simultaneously, and just had to pick one.</description>
      <content:encoded><![CDATA[<p>The slides of my talk at Percona Live 2015 (Amsterdam) are <a href="https://speakerdeck.com/nicola/mongodb-and-rest-apis-a-match-made-in-heaven">online</a>. It was titled “MongoDB and REST APIs a Match Made in Heaven” and it was meant as an introduction to Mongo, REST principles and the Eve python framework.</p>
<p>Overall it has been a pleasant experience, although I found that splitting 300 attendees through seven concurrent tracks ultimately led to too much fragmentation. People often found themselves with 2-3 interesting talks all happening simultaneously, and just had to pick one.</p>
<p>I could only stay one day so I missed all side events, speakers dinner included, which was a bummer.</p>
]]></content:encoded>
    </item>
    <item>
      <title>MongoDB and REST API go for a picnic (video and slides)</title>
      <link>https://nicolaiarocci.com/mongodb-rest-api-go-picnic-video-slides/</link>
      <pubDate>Tue, 19 Nov 2013 00:00:00 +0000</pubDate>
      <guid>https://nicolaiarocci.com/mongodb-rest-api-go-picnic-video-slides/</guid>
      <description>I had the opportunity to give my RESTful WeB APIs and MongoDB Go For A Picnic talk at both MongoTorino and NoSQL Day. The folks at PUG Friuli where so nice to record all the NoSQL Day sessions, so here you have it: the full length video of yours truly speaking to a fully packed room crowded with 120 very attentive attendees.
Unfortunately audio is horrible and while all MongoTorino talks were in english, NoSQL Day was an italian-only event.</description>
      <content:encoded><![CDATA[<p>I had the opportunity to give my <a href="https://speakerdeck.com/nicola/restful-web-api-and-mongodb-go-for-a-pic-nic">RESTful WeB APIs and MongoDB Go For A Picnic</a> talk at both <a href="http://www.mongotorino.org/">MongoTorino</a> and <a href="http://2013.nosqlday.it/">NoSQL Day</a>. The folks at PUG Friuli where so nice to record all the NoSQL Day sessions, so here you have it: the full length <a href="http://vimeo.com/79662146">video of yours truly speaking</a> to a fully packed room crowded with 120 very attentive attendees.</p>
<p>Unfortunately audio is horrible and while all MongoTorino talks were in english, NoSQL Day was an italian-only event. The slide deck is in english however, and is available on both <a href="https://speakerdeck.com/nicola/restful-web-api-and-mongodb-go-for-a-pic-nic">SpeakerDeck</a> and <a href="http://www.slideshare.net/nicolaiarocci/rest-web-api-with-mongodb">SlideShare</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Eve v0.0.8 has been released</title>
      <link>https://nicolaiarocci.com/eve-v0-0-8-has-been-released/</link>
      <pubDate>Thu, 25 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://nicolaiarocci.com/eve-v0-0-8-has-been-released/</guid>
      <description>Most significant features are probably the native support for MongoDB write concern settings, new event hooks allowing for transformation of documents before they are sent to clients, increased handling of both pagination and CORS, and the native validation of float data types.
Get it on PyPI, go straight to the source code or more likely, visit the project homepage.</description>
      <content:encoded><![CDATA[<p>Most significant features are probably the native support for MongoDB write concern settings, new event hooks allowing for transformation of documents before they are sent to clients, increased handling of both pagination and CORS, and the native validation of float data types.</p>
<p>Get it on <!-- raw HTML omitted -->PyPI<!-- raw HTML omitted -->, go straight to the <!-- raw HTML omitted -->source code<!-- raw HTML omitted --> or more likely, visit the <!-- raw HTML omitted -->project homepage<!-- raw HTML omitted -->.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Sito ufficiale e blog per il progetto Eve</title>
      <link>https://nicolaiarocci.com/sito-ufficiale-e-blog-per-il-progetto-eve/</link>
      <pubDate>Tue, 14 May 2013 00:00:00 +0000</pubDate>
      <guid>https://nicolaiarocci.com/sito-ufficiale-e-blog-per-il-progetto-eve/</guid>
      <description>E’ passato qualche mese da quando ho annunciato Eve, il REST API framework open source. Nel frattempo il progetto è cresciuto bene: siamo appena giunti alla versione 0.0.6, abbiamo un sito ufficiale, un blog, e stiamo lavorando a nuove feature davvero interessanti.</description>
      <content:encoded><![CDATA[<p>E’ passato qualche mese da quando ho <a href="http://nicolaiarocci.com/vi-presento-eve-il-framework-per-lanciare-la-vostra-rest-api-web/" title="Annuncio di Eve">annunciato</a> Eve, il REST API framework open source. Nel frattempo il progetto è cresciuto bene: siamo appena giunti alla <a href="http://blog.python-eve.org/eve-006-released" title="Eve 0.0.6">versione 0.0.6</a>, abbiamo un <a href="http://python-eve.org" title="Eve REST API homepage">sito ufficiale</a>, un <a href="http://blog.python-eve.org" title="Eve News">blog</a>, e stiamo lavorando a nuove feature <a href="http://blog.python-eve.org/sqlalchemy-and-eve" title="SqlAlchemy and Eve">davvero interessanti</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vi presento Eve il framework per le REST API Web</title>
      <link>https://nicolaiarocci.com/vi-presento-eve-il-framework-per-lanciare-la-vostra-rest-api-web/</link>
      <pubDate>Tue, 08 Jan 2013 00:00:00 +0000</pubDate>
      <guid>https://nicolaiarocci.com/vi-presento-eve-il-framework-per-lanciare-la-vostra-rest-api-web/</guid>
      <description>Lo scorso anno abbiamo lavorato duro per costruirci una RESTful Web API su misura, flessibile e completa. In corso d’opera abbiamo imparato molto sulle migliori pratiche REST, mettendo anche alla frusta le rinomate capacità Web del linguaggio Python.
Ad EuroPython 2012 ho poi raccontato la nostra esperienza e condiviso ciò che avevamo imparato. In quell’occasione mi sono reso conto di quanto l’argomento fosse d’attualità, tanto che da quel 4 luglio le slide che avevo preparato (le trovate su Speaker Deck o Slideshare) ed i video su YouTube (italiano; inglese) hanno totalizzato 30mila visite.</description>
      <content:encoded><![CDATA[<p>Lo scorso anno abbiamo lavorato duro per costruirci una RESTful Web API su misura, flessibile e completa. In corso d’opera abbiamo imparato molto sulle migliori pratiche REST, mettendo anche alla frusta le rinomate capacità Web del linguaggio Python.</p>
<p>Ad EuroPython 2012 ho poi <a href="http://nicolaiarocci.com/sviluppare-una-restful-web-api-con-python-flask-e-mongodb/">raccontato la nostra esperienza</a> e condiviso ciò che avevamo imparato. In quell’occasione mi sono reso conto di quanto l’argomento fosse d’attualità, tanto che da quel 4 luglio le slide che avevo preparato (le trovate su <!-- raw HTML omitted -->Speaker Deck<!-- raw HTML omitted --> o <!-- raw HTML omitted -->Slideshare<!-- raw HTML omitted -->) ed i video su YouTube (<!-- raw HTML omitted -->italiano<!-- raw HTML omitted -->; <!-- raw HTML omitted -->inglese<!-- raw HTML omitted -->) hanno totalizzato 30mila visite. Da allora ricevo continue richieste di chiarimenti, suggerimenti, approfondimenti, consigli. Soprattutto, mi si chiedono esempi di codice. In fin dei conti prima o poi qualunque sviluppatore web si trova, volente o nolente, a fare i conti con una REST API.</p>
<p>Così ho pensato che avrei potuto prendere il nostro codice proprietario (nome interno Adam), sistemarlo un po’ in modo che si adattasse ai casi d’uso più comuni, e rilasciarlo come progetto open source. Be’ c’è voluto un bel po’ di lavoro, ben più di quello inizialmente preventivato, ma ora ci siamo. Il progetto è finalmente disponibile, e naturalmente si chiama <!-- raw HTML omitted -->Eve<!-- raw HTML omitted -->.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Costruire e lanciare una API con Eve è semplice. Servono tre cose; un database, un file di configurazione, uno script di lancio. MongoDB è già supportato; sviluppare estensioni per altri database SQL/NoSQL non dovrebbe essere troppo complicato. Le personalizzazioni della vostra API sono salvate in un modulo standard Python. Lo script di esecuzione è in genere davvero semplice:</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Le API basate su Eve supportano l’intero range di operazioni CRUD (Create, Read, Update, Delete). Ogni end-point è personalizzabile e supporta filtri, paginazione e ordinamenti. Per massima accessibilità i client possono chiedere che le risposte pervengano in JSON oppure XML. Sono supportati gli inserimenti multipli, le direttive di caching per i client, il versioning e… tante altre cosette.</p>
<p>Non mi dilungo oltre poiché su <!-- raw HTML omitted -->GitHub<!-- raw HTML omitted --> trovate tutto quel che serve: documentazione (al momento piuttosto scarna), codice e progetti satellite. In particolare date un’occhiata a <!-- raw HTML omitted -->Eve-Demo<!-- raw HTML omitted -->, una API funzionante messa su in pochi minuti grazie a Eve. Potete consultarla direttamente, via cURL per esempio, o anche <!-- raw HTML omitted -->via browser<!-- raw HTML omitted --> (in questo caso vi beccherete del XML in risposta, mentre via cURL o altro potrete scegliere JSON). Il README di eve-demo include una serie completa di esempi relativi alle varie operazioni di lettura, inserimento, cancellazione, aggiornamento.</p>
<p>C’è ancora tanto da fare affinché Eve diventi il framework completo, stabile e maturo che ho in mente ma credo che il progetto ora sia pronto per una anteprima pubblica. In ogni caso sono lieto di dare finalmente risposta alle richieste di questi mesi: ora avete il codice; usatelo come volete. Spero anche e soprattutto di raccogliere critiche, consigli e suggerimenti; magari a qualcuno verrà anche voglia di collaborare!</p>
<p>PS: Buon 2013!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Una REST API che adatta le sue risposte al MIME Media-Type delle richieste HTTP</title>
      <link>https://nicolaiarocci.com/come-implementare-un-web-service-rest-che-adatta-le-risposte-al-mime-media-type-delle-richieste-http/</link>
      <pubDate>Fri, 03 Feb 2012 00:00:00 +0000</pubDate>
      <guid>https://nicolaiarocci.com/come-implementare-un-web-service-rest-che-adatta-le-risposte-al-mime-media-type-delle-richieste-http/</guid>
      <description>&lt;p&gt;Da qualche tempo sto lavorando alla implementazione di una REST API. In linea generale e semplificando, una &lt;!-- raw HTML omitted --&gt;API&lt;!-- raw HTML omitted --&gt; è un servizio che espone alcune funzionalità, è accessibile via internet più o meno liberamente ed è, infine, utilizzabile non solo da persone fisiche ma anche e soprattutto da altre applicazioni. Un esempio di API è quella di Facebook, che consente a chiunque di creare applicazioni che interagiscono con gli utenti e le pagine Facebook. Già, se non ci fosse la API non esisterebbero i terribili giochini Facebook…&lt;/p&gt;
&lt;p&gt;Una delle specifiche &lt;!-- raw HTML omitted --&gt;REST&lt;!-- raw HTML omitted --&gt; più importanti vuole che un servizio RESTful sia in grado di fornire dati in più formati, in modo tale da soddisfare il maggior numero possibile di utenti/applicazioni. Immaginiamo un servizio che fornisce i risultati delle partite del campionato di calcio. Supponiamo che arrivino tre richieste successive per lo stesso risultato: la prima potrebbe chiedere una risposta in formato XML, la seconda in JSON e la terza in HTML. Il  nostro servizio deve rispondere a tutte e tre le richieste, adattando il flusso di dati della risposta al formato di ognuna.&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;Nel mio caso la API che sto implementando supporta XML, JSON, HTML e testo puro. E’ scritta in Python (ma va!) e si appoggia all’eccellente &lt;!-- raw HTML omitted --&gt;Flask&lt;!-- raw HTML omitted --&gt; micro web framework. Per risolvere in maniera elegante il problema delle risposte multi-formato ho deciso di usare i &lt;!-- raw HTML omitted --&gt;decorator&lt;!-- raw HTML omitted --&gt;, una delle caratteristiche più interessanti di Python. Dopo un po’ di lavoro in proprio ho scoperto che qualcuno aveva già risolto il problema, per giunta con la stessa tecnica. &lt;!-- raw HTML omitted --&gt;MimeRender&lt;!-- raw HTML omitted --&gt; di Martin Blech è un’ottima soluzione, solo che è specifica per web.py (un altro web framework). La mia soluzione non disponeva di alcune opzioni interessanti che MimeRender include; ho deciso allora di scrivere un port di MimeRender per Flask, e di metterlo a disposizione del pubblico.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Da qualche tempo sto lavorando alla implementazione di una REST API. In linea generale e semplificando, una <!-- raw HTML omitted -->API<!-- raw HTML omitted --> è un servizio che espone alcune funzionalità, è accessibile via internet più o meno liberamente ed è, infine, utilizzabile non solo da persone fisiche ma anche e soprattutto da altre applicazioni. Un esempio di API è quella di Facebook, che consente a chiunque di creare applicazioni che interagiscono con gli utenti e le pagine Facebook. Già, se non ci fosse la API non esisterebbero i terribili giochini Facebook…</p>
<p>Una delle specifiche <!-- raw HTML omitted -->REST<!-- raw HTML omitted --> più importanti vuole che un servizio RESTful sia in grado di fornire dati in più formati, in modo tale da soddisfare il maggior numero possibile di utenti/applicazioni. Immaginiamo un servizio che fornisce i risultati delle partite del campionato di calcio. Supponiamo che arrivino tre richieste successive per lo stesso risultato: la prima potrebbe chiedere una risposta in formato XML, la seconda in JSON e la terza in HTML. Il  nostro servizio deve rispondere a tutte e tre le richieste, adattando il flusso di dati della risposta al formato di ognuna.</p>
<p><!-- raw HTML omitted -->Nel mio caso la API che sto implementando supporta XML, JSON, HTML e testo puro. E’ scritta in Python (ma va!) e si appoggia all’eccellente <!-- raw HTML omitted -->Flask<!-- raw HTML omitted --> micro web framework. Per risolvere in maniera elegante il problema delle risposte multi-formato ho deciso di usare i <!-- raw HTML omitted -->decorator<!-- raw HTML omitted -->, una delle caratteristiche più interessanti di Python. Dopo un po’ di lavoro in proprio ho scoperto che qualcuno aveva già risolto il problema, per giunta con la stessa tecnica. <!-- raw HTML omitted -->MimeRender<!-- raw HTML omitted --> di Martin Blech è un’ottima soluzione, solo che è specifica per web.py (un altro web framework). La mia soluzione non disponeva di alcune opzioni interessanti che MimeRender include; ho deciso allora di scrivere un port di MimeRender per Flask, e di metterlo a disposizione del pubblico.</p>
<h2 id="istruzioni-per-l8217uso">Istruzioni per l’uso</h2>
<p>Prima di tutto è necessario fornire le funzioni da usare per il rendering, una per ogni formato che intendiamo supportare:</p>
<!-- raw HTML omitted -->
<p>Quindi decoriamo la nostra funzione, definendo per lei la mappa delle funzioni di rendering:</p>
<!-- raw HTML omitted -->
<p>Tutto qui! In caso di richiesta GET la funzione <code>index</code> restituisce un dizionario, il quale verrà reso da MimeRender come XML, JSON o quant’altro, a seconda del Content-Type specificato nella richiesta HTTP:</p>
<!-- raw HTML omitted -->
<p>Su <!-- raw HTML omitted -->github <!-- raw HTML omitted -->trovate l’esempio completo nonché il codice sorgente del renderer, che potete scaricare liberamente.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
