<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on Nicola Iarocci</title>
    <link>https://nicolaiarocci.com/tags/docker/</link>
    <description>Recent content in docker on Nicola Iarocci</description>
    <image>
      <title>Nicola Iarocci</title>
      <url>https://nicolaiarocci.com/images/avatar.png</url>
      <link>https://nicolaiarocci.com/images/avatar.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Produced / Written / Maintained by [Nicola Iarocci](/) since 2010</copyright>
    <lastBuildDate>Thu, 08 Sep 2022 07:05:25 +0100</lastBuildDate>
    <atom:link href="https://nicolaiarocci.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Docker Event Monitor</title>
      <link>https://nicolaiarocci.com/the-docker-event-monitor/</link>
      <pubDate>Thu, 08 Sep 2022 07:05:25 +0100</pubDate>
      <guid>https://nicolaiarocci.com/the-docker-event-monitor/</guid>
      <description>How to get alerted when a docker container goes down, or (many) other things happen to it</description>
      <content:encoded><![CDATA[<p>I added a new tool to my amateurish DevOps toolbox. Developed in the open by
Tom Williams, the <a href="https://bitbucket.org/quaideman/dem">Docker Event Monitor is</a> a &ldquo;tiny container that monitors
the local Docker event system in real-time and sends notifications to various
integrations for event types that match the configuration. For example, you can
trigger an alert when a container is stopped, killed, runs out of memory or
health status change.&rdquo;</p>
<p>At its core sits a simple <a href="https://bitbucket.org/quaideman/dem/src/master/app/main.py">python script</a> that monitors the <code>docker.sock</code>
file for noticeable changes. The code is straightforward and looks safe to
me. It only took a few minutes to set DEM up so that our <code>alerts</code> channel on
Slack gets notified of any health status changes. Some handy options are
included; my favorite is <code>silence</code> to set a time window during which alerts are
not fired. It avoids unnecessary spam when routine maintenance goes off on your
stack.</p>
<p>I find <a href="https://bitbucket.org/quaideman/dem">DEM</a> a useful little tool for lightweight, simple deployments where
you&rsquo;re not employing heavy weaponry, like k8s.</p>
]]></content:encoded>
    </item>
    <item>
      <title>How to automatically pull and deploy updated Docker images</title>
      <link>https://nicolaiarocci.com/how-to-automatically-pull-and-deploy-updated-docker-images/</link>
      <pubDate>Sun, 21 Nov 2021 07:05:25 +0100</pubDate>
      <guid>https://nicolaiarocci.com/how-to-automatically-pull-and-deploy-updated-docker-images/</guid>
      <description>We want our test and production stacks to be automatically updated every time something new is pushed to the test or release branch. CI builds the docker image on successful test runs, then stores it in our private registry. But how do you automatically pull and deploy those updated images?
I looked into the Watchtower project, which is interesting. You add Watchtower to the stack, and it will diligently check for new versions of the images used by the containers in the stack, pulling, building and deploying as needed while the stack is up and running.</description>
      <content:encoded><![CDATA[<p>We want our test and production stacks to be automatically updated every time
something new is pushed to the <code>test</code> or <code>release</code> branch. CI builds the docker
image on successful test runs, then stores it in our private registry. But how
do you automatically pull and deploy those updated images?</p>
<p>I looked into the <a href="https://containrrr.dev/watchtower/">Watchtower</a> project, which is interesting. You add
Watchtower to the stack, and it will diligently check for new versions of the
images used by the containers in the stack, pulling, building and deploying as
needed while the stack is up and running. In my experiments, however, I had
<a href="https://github.com/containrrr/watchtower/issues/1113">little luck</a> in making it talk with our private registry. Also, I&rsquo;m not too
fond of polluting my stack with foreign containers. I want my docker stack to
be simple, tidy, clean, and single-tasked.</p>
<p>I ended up doing something super simple. A cronjob routinely invokes a script
that pulls relevant images from our registry. If updated images are downloaded,
then the <code>docker stack up</code> command is issued.  Finally, a <code>docker image prune -af</code> ensures obsolete images are deleted. For the simplest scenario, where we
only need to take care of one image, the script looks like this:</p>
<pre><code>#!/bin/bash
set -e

readonly IMAGE=[image]
readonly TAG=[tag]

out=$(docker pull $IMAGE:$TAG)

if [[ $out != *&quot;up to date&quot;* ]]; then
    echo &quot;an updated image has been donwloaded for '$IMAGE:$TAG'&quot;
    # we actually launch a script here:
    docker stack up -c stack.yml mystack --with-registry-auth
    docker image prune -af
else
    echo &quot;no updates available for '$IMAGE:$TAG'&quot;
fi
</code></pre>
<p>I expected <code>docker pull</code> to return <code>1</code> on successful pulls; it turns out it
always returns <code>0</code>, so I&rsquo;m checking its output for confirmation (I got the hint
<a href="https://stackoverflow.com/a/51628017/323269">here</a>).</p>
<p>You might be wondering why we don&rsquo;t directly execute <code>docker stack up</code> in our
cronjob. It updates the stack resolving new images by default. The problem is
that, in our experience, it also briefly stops the services. Not an issue if
you run this command sporadically. We want our stacks refreshed minutes after
the initial developer push, though, so the cronjob runs frequently. With our
pre-fetch approach, actual deployment only happens when an updated image has
been found and downloaded.</p>
<p>Now, when I push to, say, <code>test</code> branch, I have the updated services up and
running a minute later, without me doing anything on the docker or server-side
of things. Mission accomplished, I guess, but I am sure there are other, better
ways around this problem. If you happen to know one, please let me know about
it (keep in mind, we don&rsquo;t use alternative orchestrators, just the built-in
&lsquo;swarm&rsquo; thing.)</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
