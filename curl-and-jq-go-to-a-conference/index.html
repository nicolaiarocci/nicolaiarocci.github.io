<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Curl and jq go to a conference | Nicola Iarocci</title>
<meta name=keywords content="curl,jq,speaking,bash"><meta name=description content="I&rsquo;m presenting at the WPC 2025 Conference on December 3rd in Milan. My session topic is Feature Flag Management and Dynamic Configurations in C#. I will use a Web API as an example project, and since I&rsquo;ll be using curl live to query the it, I&rsquo;ll need to pipe responses through jq to obtain nicely formatted JSON for the audience.
The problem with jq is that it crashes on 400s or 500s because the response body is empty in those cases. Error responses are inherent to the demo, and crashes are not the most desirable thing during a presentation."><meta name=author content><link rel=canonical href=https://nicolaiarocci.com/curl-and-jq-go-to-a-conference/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nicolaiarocci.com/curl-and-jq-go-to-a-conference/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://nicolaiarocci.com/curl-and-jq-go-to-a-conference/"><meta property="og:site_name" content="Nicola Iarocci"><meta property="og:title" content="Curl and jq go to a conference"><meta property="og:description" content="I’m presenting at the WPC 2025 Conference on December 3rd in Milan. My session topic is Feature Flag Management and Dynamic Configurations in C#. I will use a Web API as an example project, and since I’ll be using curl live to query the it, I’ll need to pipe responses through jq to obtain nicely formatted JSON for the audience.
The problem with jq is that it crashes on 400s or 500s because the response body is empty in those cases. Error responses are inherent to the demo, and crashes are not the most desirable thing during a presentation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-11-21T16:57:44+01:00"><meta property="article:modified_time" content="2025-11-21T16:57:44+01:00"><meta property="article:tag" content="Curl"><meta property="article:tag" content="Jq"><meta property="article:tag" content="Speaking"><meta property="article:tag" content="Bash"><meta name=twitter:card content="summary"><meta name=twitter:title content="Curl and jq go to a conference"><meta name=twitter:description content="I&rsquo;m presenting at the WPC 2025 Conference on December 3rd in Milan. My session topic is Feature Flag Management and Dynamic Configurations in C#. I will use a Web API as an example project, and since I&rsquo;ll be using curl live to query the it, I&rsquo;ll need to pipe responses through jq to obtain nicely formatted JSON for the audience.
The problem with jq is that it crashes on 400s or 500s because the response body is empty in those cases. Error responses are inherent to the demo, and crashes are not the most desirable thing during a presentation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"Curl and jq go to a conference","item":"https://nicolaiarocci.com/curl-and-jq-go-to-a-conference/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Curl and jq go to a conference","name":"Curl and jq go to a conference","description":"I\u0026rsquo;m presenting at the WPC 2025 Conference on December 3rd in Milan. My session topic is Feature Flag Management and Dynamic Configurations in C#. I will use a Web API as an example project, and since I\u0026rsquo;ll be using curl live to query the it, I\u0026rsquo;ll need to pipe responses through jq to obtain nicely formatted JSON for the audience.\nThe problem with jq is that it crashes on 400s or 500s because the response body is empty in those cases. Error responses are inherent to the demo, and crashes are not the most desirable thing during a presentation.\n","keywords":["curl","jq","speaking","bash"],"articleBody":"I’m presenting at the WPC 2025 Conference on December 3rd in Milan. My session topic is Feature Flag Management and Dynamic Configurations in C#. I will use a Web API as an example project, and since I’ll be using curl live to query the it, I’ll need to pipe responses through jq to obtain nicely formatted JSON for the audience.\nThe problem with jq is that it crashes on 400s or 500s because the response body is empty in those cases. Error responses are inherent to the demo, and crashes are not the most desirable thing during a presentation.\nI cooked up a quick bash function that enhances curl and jq. It is called cj (curl + jq) and prevents crashes on errors, displays HTTP status codes with color-coded output (green for success, red for errors), and prettifies JSON responses.1\nAs I fully expect someone in the audience to raise their hand and ask what the hell “cj” is, I’m posting it for reference so I can point them here if needed (Hi there!).\nThe function looks like this:\ncj() { local response http_code body response=$(curl -s -w \"\\n%{http_code}\" \"$@\") http_code=${response##*$'\\n'} body=${response%$'\\n'*} if [[ $http_code =~ ^2[0-9][0-9]$ ]]; then echo -e \"\\033[0;32mHTTP Code: $http_code\\033[0m\" echo \"$body\" | jq 2\u003e/dev/null || echo \"$body\" else echo -e \"\\033[0;31mHTTP Code: $http_code\\033[0m\" echo -e \"\\033[0;31m$body\\033[0m\" fi } It currently sits at the bottom of my .zshrc file. I might turn it into a script in the future, but it’s probably going to be short-lived, so I’m happy with its current residence.\nIt’s pretty straightforward, but let’s break it down line by line.\ncj() { Defines a function named cj (short for “curl with jq”), which will wrap the standard curl command with automatic JSON formatting and colored output.\nlocal response http_code body Declares three local variables scoped to this function: response will store the full curl output, http_code will contain the HTTP status code, and body will hold the response body.\nresponse=$(curl -s -w \"\\n%{http_code}\" \"$@\") Executes curl with the -s flag for silent mode (no progress bar), -w \"\\n%{http_code}\" to append a newline and the HTTP status code at the end of the output, and \"$@\" to forward all arguments passed to the function. The entire output is captured in the response variable.\nhttp_code=${response##*$'\\n'} Extracts the HTTP status code using Bash parameter expansion. The ##*$'\\n' pattern removes everything up to and including the last newline, leaving only the status code. This is faster than using external commands like tail.\nbody=${response%$'\\n'*} Extracts the response body using parameter expansion. The %$'\\n'* pattern removes the last newline and everything after it (the status code), leaving only the body content. This is more efficient than using, say, sed.\nif [[ $http_code =~ ^2[0-9][0-9]$ ]]; then Checks if the HTTP status code matches the pattern for success responses (2xx). The regex ^2[0-9][0-9]$ matches any three-digit number starting with 2.\necho -e \"\\033[0;32mHTTP Code: $http_code\\033[0m\" Prints the HTTP status code in green color. The -e flag enables interpretation of backslash escapes, \\033[0;32m is the ANSI code for green text, and \\033[0m resets the color back to default.\necho \"$body\" | jq 2\u003e/dev/null || echo \"$body\" This one was fun. Attempts to format the response body as JSON using jq. If jq is not installed or the body isn’t valid JSON, stderr is redirected to /dev/null and the || operator triggers the fallback, which simply prints the raw body.\nelse echo -e \"\\033[0;31mHTTP Code: $http_code\\033[0m\" For non-2xx responses (errors), prints the HTTP status code in red color using the ANSI code \\033[0;31m.\necho -e \"\\033[0;31m$body\\033[0m\" Prints the error response body also in red color, making errors immediately visible during the demo.\nAnd that is all.\nI could improve the API to return valid JSON even on errors, but that’s boring. ↩︎\n","wordCount":"630","inLanguage":"en","datePublished":"2025-11-21T16:57:44+01:00","dateModified":"2025-11-21T16:57:44+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/curl-and-jq-go-to-a-conference/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com/ accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buttondown.email/nicolaiarocci title=subscribe><span>subscribe</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Curl and jq go to a conference</h1><div class=post-meta><span title='2025-11-21 16:57:44 +0100 CET'>November 21, 2025</span></div></header><div class=post-content><p>I&rsquo;m presenting at the <a href=https://www.wpc.education>WPC 2025 Conference</a> on December 3rd in Milan. My session topic is Feature Flag Management and Dynamic Configurations in C#. I will use a Web API as an example project, and since I&rsquo;ll be using curl live to query the it, I&rsquo;ll need to pipe responses through <a href=https://jqlang.org>jq</a> to obtain nicely formatted JSON for the audience.</p><p>The problem with jq is that it crashes on 400s or 500s because the response body is empty in those cases. Error responses are inherent to the demo, and crashes are not the most desirable thing during a presentation.</p><p>I cooked up a quick bash function that enhances curl and jq. It is called cj (curl + jq) and prevents crashes on errors, displays HTTP status codes with color-coded output (green for success, red for errors), and prettifies JSON responses.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>As I fully expect someone in the audience to raise their hand and ask what the hell &ldquo;cj&rdquo; is, I&rsquo;m posting it for reference so I can point them here if needed (Hi there!).</p><p>The function looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cj() {
</span></span><span style=display:flex><span>    local response http_code body
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    response=<span style=font-weight:700>$(</span>curl -s -w <span style=font-style:italic>&#34;\n%{http_code}&#34;</span> <span style=font-style:italic>&#34;</span>$@<span style=font-style:italic>&#34;</span><span style=font-weight:700>)</span>
</span></span><span style=display:flex><span>    http_code=<span style=font-weight:700;font-style:italic>${</span>response##*<span style=font-style:italic>$&#39;\n&#39;</span><span style=font-weight:700;font-style:italic>}</span>
</span></span><span style=display:flex><span>    body=<span style=font-weight:700;font-style:italic>${</span>response%<span style=font-style:italic>$&#39;\n&#39;</span>*<span style=font-weight:700;font-style:italic>}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> [[ $http_code =~ ^2[0-9][0-9]$ ]]; <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>        echo -e <span style=font-style:italic>&#34;\033[0;32mHTTP Code: </span>$http_code<span style=font-style:italic>\033[0m&#34;</span>
</span></span><span style=display:flex><span>        echo <span style=font-style:italic>&#34;</span>$body<span style=font-style:italic>&#34;</span> | jq 2&gt;/dev/null || echo <span style=font-style:italic>&#34;</span>$body<span style=font-style:italic>&#34;</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>        echo -e <span style=font-style:italic>&#34;\033[0;31mHTTP Code: </span>$http_code<span style=font-style:italic>\033[0m&#34;</span>
</span></span><span style=display:flex><span>        echo -e <span style=font-style:italic>&#34;\033[0;31m</span>$body<span style=font-style:italic>\033[0m&#34;</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>fi</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It currently sits at the bottom of my .zshrc file. I might turn it into a script in the future, but it&rsquo;s probably going to be short-lived, so I&rsquo;m happy with its current residence.</p><p>It&rsquo;s pretty straightforward, but let&rsquo;s break it down line by line.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cj() {
</span></span></code></pre></div><p>Defines a function named cj (short for &ldquo;curl with jq&rdquo;), which will wrap the standard curl command with automatic JSON formatting and colored output.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>local response http_code body
</span></span></code></pre></div><p>Declares three local variables scoped to this function: <code>response</code> will store the full curl output, <code>http_code</code> will contain the HTTP status code, and <code>body</code> will hold the response body.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>response=<span style=font-weight:700>$(</span>curl -s -w <span style=font-style:italic>&#34;\n%{http_code}&#34;</span> <span style=font-style:italic>&#34;</span>$@<span style=font-style:italic>&#34;</span><span style=font-weight:700>)</span>
</span></span></code></pre></div><p>Executes curl with the <code>-s</code> flag for silent mode (no progress bar), <code>-w "\n%{http_code}"</code> to append a newline and the HTTP status code at the end of the output, and <code>"$@"</code> to forward all arguments passed to the function. The entire output is captured in the response variable.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>http_code=<span style=font-weight:700;font-style:italic>${</span>response##*<span style=font-style:italic>$&#39;\n&#39;</span><span style=font-weight:700;font-style:italic>}</span>
</span></span></code></pre></div><p>Extracts the HTTP status code using Bash parameter expansion. The <code>##*$'\n'</code> pattern removes everything up to and including the last newline, leaving only the status code. This is faster than using external commands like tail.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>body=<span style=font-weight:700;font-style:italic>${</span>response%<span style=font-style:italic>$&#39;\n&#39;</span>*<span style=font-weight:700;font-style:italic>}</span>
</span></span></code></pre></div><p>Extracts the response body using parameter expansion. The <code>%$'\n'*</code> pattern removes the last newline and everything after it (the status code), leaving only the body content. This is more efficient than using, say, sed.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=font-weight:700>if</span> [[ $http_code =~ ^2[0-9][0-9]$ ]]; <span style=font-weight:700>then</span>
</span></span></code></pre></div><p>Checks if the HTTP status code matches the pattern for success responses (2xx). The regex <code>^2[0-9][0-9]$</code> matches any three-digit number starting with 2.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo -e <span style=font-style:italic>&#34;\033[0;32mHTTP Code: </span>$http_code<span style=font-style:italic>\033[0m&#34;</span>
</span></span></code></pre></div><p>Prints the HTTP status code in green color. The <code>-e</code> flag enables interpretation of backslash escapes, <code>\033[0;32m</code> is the ANSI code for green text, and <code>\033[0m</code> resets the color back to default.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=font-style:italic>&#34;</span>$body<span style=font-style:italic>&#34;</span> | jq 2&gt;/dev/null || echo <span style=font-style:italic>&#34;</span>$body<span style=font-style:italic>&#34;</span>
</span></span></code></pre></div><p>This one was fun. Attempts to format the response body as JSON using jq. If jq is not installed or the body isn&rsquo;t valid JSON, stderr is redirected to <code>/dev/null</code> and the <code>||</code> operator triggers the fallback, which simply prints the raw body.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>        echo -e <span style=font-style:italic>&#34;\033[0;31mHTTP Code: </span>$http_code<span style=font-style:italic>\033[0m&#34;</span>
</span></span></code></pre></div><p>For non-2xx responses (errors), prints the HTTP status code in red color using the ANSI code <code>\033[0;31m</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo -e <span style=font-style:italic>&#34;\033[0;31m</span>$body<span style=font-style:italic>\033[0m&#34;</span>
</span></span></code></pre></div><p>Prints the error response body also in red color, making errors immediately visible during the demo.</p><p>And that is all.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I could improve the API to return valid JSON even on errors, but that&rsquo;s boring.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/curl/>Curl</a></li><li><a href=https://nicolaiarocci.com/tags/jq/>Jq</a></li><li><a href=https://nicolaiarocci.com/tags/speaking/>Speaking</a></li><li><a href=https://nicolaiarocci.com/tags/bash/>Bash</a></li></ul><nav class=paginav><a class=prev href=https://nicolaiarocci.com/people-who-no-longer-read-as-much-as-they-used-to/><span class=title>« Prev</span><br><span>People who no longer read as much as they used to</span>
</a><a class=next href=https://nicolaiarocci.com/curl-and-jq-go-to-a-conference/><span class=title>Next »</span><br><span>Curl and jq go to a conference</span></a></nav></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>