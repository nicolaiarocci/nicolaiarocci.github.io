<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>On implementing the ASP.NET Core 7 rate-limiting middleware | Nicola Iarocci</title>
<meta name=keywords content="dotnet,rate-limiting,programming,til"><meta name=description content="Today, my last self-assigned duty before the Christmas break was to migrate
our in-house rate-limiting implementation (based on the
AspNetCoreRateLimiting third-party package) to the new, shiny
rate-limiting middleware introduced by ASP.NET Core 7. While the process
was relatively straightforward, I stumbled upon a few quirks I want to annotate
here.
Our use case is simple. We use what the ASP.NET Core 7 documentation defines as
a &ldquo;fixed window limiter.&rdquo; It uses a specified time window to limit requests.
When the time window expires, a new time window starts, and the request limit
is reset. Consider the following code (for convenience, I&rsquo;m using an extension
method):"><meta name=author content><link rel=canonical href=https://nicolaiarocci.com/on-implementing-the-asp.net-core-7-rate-limiting-middleware/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nicolaiarocci.com/on-implementing-the-asp.net-core-7-rate-limiting-middleware/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://nicolaiarocci.com/on-implementing-the-asp.net-core-7-rate-limiting-middleware/"><meta property="og:site_name" content="Nicola Iarocci"><meta property="og:title" content="On implementing the ASP.NET Core 7 rate-limiting middleware"><meta property="og:description" content="Today, my last self-assigned duty before the Christmas break was to migrate our in-house rate-limiting implementation (based on the AspNetCoreRateLimiting third-party package) to the new, shiny rate-limiting middleware introduced by ASP.NET Core 7. While the process was relatively straightforward, I stumbled upon a few quirks I want to annotate here.
Our use case is simple. We use what the ASP.NET Core 7 documentation defines as a “fixed window limiter.” It uses a specified time window to limit requests. When the time window expires, a new time window starts, and the request limit is reset. Consider the following code (for convenience, I’m using an extension method):"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-23T07:05:25+01:00"><meta property="article:modified_time" content="2022-12-23T07:05:25+01:00"><meta property="article:tag" content="Dotnet"><meta property="article:tag" content="Rate-Limiting"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Til"><meta name=twitter:card content="summary"><meta name=twitter:title content="On implementing the ASP.NET Core 7 rate-limiting middleware"><meta name=twitter:description content="Today, my last self-assigned duty before the Christmas break was to migrate
our in-house rate-limiting implementation (based on the
AspNetCoreRateLimiting third-party package) to the new, shiny
rate-limiting middleware introduced by ASP.NET Core 7. While the process
was relatively straightforward, I stumbled upon a few quirks I want to annotate
here.
Our use case is simple. We use what the ASP.NET Core 7 documentation defines as
a &ldquo;fixed window limiter.&rdquo; It uses a specified time window to limit requests.
When the time window expires, a new time window starts, and the request limit
is reset. Consider the following code (for convenience, I&rsquo;m using an extension
method):"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"On implementing the ASP.NET Core 7 rate-limiting middleware","item":"https://nicolaiarocci.com/on-implementing-the-asp.net-core-7-rate-limiting-middleware/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"On implementing the ASP.NET Core 7 rate-limiting middleware","name":"On implementing the ASP.NET Core 7 rate-limiting middleware","description":"Today, my last self-assigned duty before the Christmas break was to migrate our in-house rate-limiting implementation (based on the AspNetCoreRateLimiting third-party package) to the new, shiny rate-limiting middleware introduced by ASP.NET Core 7. While the process was relatively straightforward, I stumbled upon a few quirks I want to annotate here.\nOur use case is simple. We use what the ASP.NET Core 7 documentation defines as a \u0026ldquo;fixed window limiter.\u0026rdquo; It uses a specified time window to limit requests. When the time window expires, a new time window starts, and the request limit is reset. Consider the following code (for convenience, I\u0026rsquo;m using an extension method):\n","keywords":["dotnet","rate-limiting","programming","til"],"articleBody":"Today, my last self-assigned duty before the Christmas break was to migrate our in-house rate-limiting implementation (based on the AspNetCoreRateLimiting third-party package) to the new, shiny rate-limiting middleware introduced by ASP.NET Core 7. While the process was relatively straightforward, I stumbled upon a few quirks I want to annotate here.\nOur use case is simple. We use what the ASP.NET Core 7 documentation defines as a “fixed window limiter.” It uses a specified time window to limit requests. When the time window expires, a new time window starts, and the request limit is reset. Consider the following code (for convenience, I’m using an extension method):\npublic static void ConfigureRateLimit(this IServiceCollection services) { services.AddRateLimiter(x =\u003e x.AddFixedWindowLimiter( policyName: \"fixed\", options =\u003e { options.PermitLimit 1; options.Window = TimeSpan.FromSeconds(10); options.QueueLimit 1; })); } It sets a window of 10 seconds. Within that window, a maximum of one request is allowed. Exceeding requests will be queued and served at window reset. Notice that we defined “fixed” as the policy name.\nOnce our policy is configured, we must instrument the app instance to use the rate limiter, then we call RequireRateLimiting on our endpoints:\napp.UseRouting(); // I'm mentioning this line for good reason, see below app.UseRateLimiter(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers() .RequireRateLimiting(\"fixed\"); }); Nothing else is needed, really, for such a simple scenario. We could be more sophisticated. We could opt for more advanced options, like a “sliding windows limiter” or a “bucket token limiter”; we could apply rate limiting only to specific endpoints or controllers or mix and match these options. I chose to ditch hard-coded settings and read them from the configuration file. My appsettings.json contains the following (with different vaues):\n\"RateLimiter\": { \"PermitLimit\": 1 \"Window\": 10, \"QueueLimit\": 1 } The RateLimiter class maps the json structure:\npublic class RateLimiter { public int PermitLimit { get; set; } public int Window { get; set; } public int QueueLimit { get; set; } } The updated code looks like this:\npublic static void ConfigureRateLimit(this IServiceCollection services, IConfiguration configuration) { var rateLimiter = new RateLimiter(); configuration.GetSection(\"RateLimiter\").Bind(rateLimiter); services.AddRateLimiter(x =\u003e x.AddFixedWindowLimiter( policyName: \"fixed\", options =\u003e { options.PermitLimit = rateLimiter.PermitLimit; options.Window = TimeSpan.FromSeconds(rateLimiter.Window); options.QueueLimit = rateLimiter.QueueLimit; })); } I wish I could say it all worked splendidly on the first try. The API was running fine, but it was not rate-limited. It looked like the middleware was not being invoked, or it somehow failed miserably and silently. After an embarrassingly long time, I figured out the problem: UseRateLimiter must be called after UseRouting.\nBefore:\napp.UseRateLimiter(); app.UseRouting(); app.UseEndpoints(endpoints =\u003e { endpoints .MapControllers().RequireRateLimiting(\"fixed\"); }); After:\napp.UseRouting(); app.UseRateLimiter(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers() .RequireRateLimiting(\"fixed\"); }); Simply switching two lines saved the day. I looked high and low but could not find any reference to this requirement. If intended, it should be mentioned in the documentation. If it is a bug, it should be fixed (and I should probably open at ticket about it.)\nAnyways, now the API is rate-limited via the new middleware. The first request sent via Postman goes through. The second, rapid-fired one is queued and served at window reset, as expected. A third request within the same window is bounced back.\nHowever:\nYou get a 503 Service Unavailable response. I’m not in favor of 500 replies for this case. Five-hundreds should be reserved for server errors, and that’s not what we are dealing with here. My previous implementation served a more appropriate 429 Too Many Requests. No Retry-After header is included with the response. I think it’s mandatory to instruct clients on what to do next. Luckily, the rate-limiting middleware allows for ample customization. On defining our policy, we can attach a custom function to the OnRejected event. The code below is updated to address both issues above:\npublic static class ServicesConfiguration { public static void ConfigureRateLimit(this IServiceCollection services, IConfiguration configuration) { var rateLimiter = new RateLimiter(); configuration.GetSection(\"RateLimiter\").Bind(rateLimiter); services.AddRateLimiter(x =\u003e x.AddFixedWindowLimiter( policyName: \"fixed\", options =\u003e { options.PermitLimit = rateLimiter.PermitLimit; options.Window = TimeSpan.FromSeconds(rateLimiter.Window); options.QueueLimit = rateLimiter.QueueLimit; }) // new code here: .OnRejected = (context, _) =\u003e { // inject Retry-After header (too much line wrapping, I know) if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter)) { context.HttpContext.Response.Headers.RetryAfter = ((int) retryAfter.TotalSeconds).ToString(); } // return a different status code context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests; return new(); }); } And that’s all there is to it. I dropped the AspNetCoreRateLimiting dependency. That is one great piece of software, and I am grateful to its author Stefan Prodan and his contributors. As mentioned in My Top 7 New Features in .NET 7, they recently released a package that allows using Redis as a rate-limiting backend. I might adopt it in the future.\nComplete documentation for ASP.NET Core 7 rate-limiting middleware is available here.\n","wordCount":"772","inLanguage":"en","datePublished":"2022-12-23T07:05:25+01:00","dateModified":"2022-12-23T07:05:25+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/on-implementing-the-asp.net-core-7-rate-limiting-middleware/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com/ accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title=newsletter><span>newsletter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">On implementing the ASP.NET Core 7 rate-limiting middleware</h1><div class=post-meta><span title='2022-12-23 07:05:25 +0100 CET'>December 23, 2022</span></div></header><div class=post-content><p>Today, my last self-assigned duty before the Christmas break was to migrate
our in-house rate-limiting implementation (based on the
<a href=https://github.com/stefanprodan/AspNetCoreRateLimit>AspNetCoreRateLimiting</a> third-party package) to the new, shiny
<a href=https://devblogs.microsoft.com/dotnet/announcing-rate-limiting-for-dotnet/>rate-limiting middleware</a> introduced by ASP.NET Core 7. While the process
was relatively straightforward, I stumbled upon a few quirks I want to annotate
here.</p><p>Our use case is simple. We use what the ASP.NET Core 7 documentation defines as
a &ldquo;fixed window limiter.&rdquo; It uses a specified time window to limit requests.
When the time window expires, a new time window starts, and the request limit
is reset. Consider the following code (for convenience, I&rsquo;m using an extension
method):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public static void ConfigureRateLimit(this IServiceCollection services)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    services.AddRateLimiter(x =&gt; 
</span></span><span style=display:flex><span>        x.AddFixedWindowLimiter(
</span></span><span style=display:flex><span>                policyName: &#34;fixed&#34;, options =&gt;
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    options.PermitLimit 1;
</span></span><span style=display:flex><span>                    options.Window = TimeSpan.FromSeconds(10);
</span></span><span style=display:flex><span>                    options.QueueLimit 1;
</span></span><span style=display:flex><span>                }));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It sets a window of 10 seconds. Within that window, a maximum of one request is
allowed. Exceeding requests will be queued and served at window reset. Notice
that we defined &ldquo;fixed&rdquo; as the policy name.</p><p>Once our policy is configured, we must instrument the app instance to use the
rate limiter, then we call <code>RequireRateLimiting</code> on our endpoints:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>app.UseRouting();  // I&#39;m mentioning this line for good reason, see below
</span></span><span style=display:flex><span>app.UseRateLimiter();
</span></span><span style=display:flex><span>app.UseEndpoints(endpoints =&gt; { endpoints.MapControllers()
</span></span><span style=display:flex><span>    .RequireRateLimiting(&#34;fixed&#34;); });
</span></span></code></pre></div><p>Nothing else is needed, really, for such a simple scenario. We could be more
sophisticated. We could opt for more advanced options, like a &ldquo;sliding windows
limiter&rdquo; or a &ldquo;bucket token limiter&rdquo;; we could apply rate limiting only to
specific endpoints or controllers or mix and match these options. I chose to
ditch hard-coded settings and read them from the configuration file. My
<em>appsettings.json</em> contains the following (with different vaues):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  &#34;RateLimiter&#34;: {
</span></span><span style=display:flex><span>    &#34;PermitLimit&#34;: 1
</span></span><span style=display:flex><span>    &#34;Window&#34;: 10,
</span></span><span style=display:flex><span>    &#34;QueueLimit&#34;: 1
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>The <code>RateLimiter</code> class maps the json structure:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class RateLimiter
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    public int PermitLimit { get; set; }
</span></span><span style=display:flex><span>    public int Window { get; set; }
</span></span><span style=display:flex><span>    public int QueueLimit { get; set; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The updated code looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>public <span style=font-weight:700>static</span> void ConfigureRateLimit(this IServiceCollection services, 
</span></span><span style=display:flex><span>    IConfiguration configuration)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=font-weight:700>var</span> rateLimiter = new RateLimiter();
</span></span><span style=display:flex><span>    configuration.GetSection(<span style=font-style:italic>&#34;RateLimiter&#34;</span>).Bind(rateLimiter);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    services.AddRateLimiter(x =&gt; 
</span></span><span style=display:flex><span>        x.AddFixedWindowLimiter(
</span></span><span style=display:flex><span>                policyName: <span style=font-style:italic>&#34;fixed&#34;</span>, options =&gt;
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    options.PermitLimit = rateLimiter.PermitLimit;
</span></span><span style=display:flex><span>                    options.Window = TimeSpan.FromSeconds(rateLimiter.Window);
</span></span><span style=display:flex><span>                    options.QueueLimit = rateLimiter.QueueLimit;
</span></span><span style=display:flex><span>                }));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I wish I could say it all worked splendidly on the first try. The API was
running fine, but it was not rate-limited. It looked like the middleware was
not being invoked, or it somehow failed miserably and silently. After an
embarrassingly long time, I figured out the problem: <code>UseRateLimiter</code>
<em>must</em> be called after <code>UseRouting</code>.</p><p>Before:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>app.UseRateLimiter();
</span></span><span style=display:flex><span>app.UseRouting();
</span></span><span style=display:flex><span>app.UseEndpoints(endpoints =&gt; { endpoints
</span></span><span style=display:flex><span>    .MapControllers().RequireRateLimiting(&#34;fixed&#34;); });
</span></span></code></pre></div><p>After:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>app.UseRouting();
</span></span><span style=display:flex><span>app.UseRateLimiter();
</span></span><span style=display:flex><span>app.UseEndpoints(endpoints =&gt; { endpoints.MapControllers()
</span></span><span style=display:flex><span>    .RequireRateLimiting(&#34;fixed&#34;); });
</span></span></code></pre></div><p>Simply switching two lines saved the day. I looked high and low but could not
find any reference to this requirement. If intended, it should be mentioned in
the documentation. If it is a bug, it should be fixed (and I should
probably open at ticket about it.)</p><p>Anyways, now the API is rate-limited via the new middleware. The first request
sent via Postman goes through. The second, rapid-fired one is queued and served
at window reset, as expected. A third request within the same window is bounced
back.</p><p>However:</p><ol><li>You get a <code>503 Service Unavailable</code> response. I&rsquo;m not in favor of 500
replies for this case. Five-hundreds should be reserved for server errors,
and that&rsquo;s not what we are dealing with here. My previous implementation
served a more appropriate <code>429 Too Many Requests</code>.</li><li>No <code>Retry-After</code> header is included with the response. I think it&rsquo;s
mandatory to instruct clients on what to do next.</li></ol><p>Luckily, the rate-limiting middleware allows for ample customization. On
defining our policy, we can attach a custom function to the <code>OnRejected</code> event.
The code below is updated to address both issues above:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>public <span style=font-weight:700>static</span> <span style=font-weight:700>class</span> ServicesConfiguration
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    public <span style=font-weight:700>static</span> void ConfigureRateLimit(this IServiceCollection services, 
</span></span><span style=display:flex><span>        IConfiguration configuration) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>var</span> rateLimiter = new RateLimiter();
</span></span><span style=display:flex><span>        configuration.GetSection(<span style=font-style:italic>&#34;RateLimiter&#34;</span>).Bind(rateLimiter);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        services.AddRateLimiter(x =&gt; 
</span></span><span style=display:flex><span>            x.AddFixedWindowLimiter(
</span></span><span style=display:flex><span>                    policyName: <span style=font-style:italic>&#34;fixed&#34;</span>, options =&gt; {
</span></span><span style=display:flex><span>                        options.PermitLimit = rateLimiter.PermitLimit;
</span></span><span style=display:flex><span>                        options.Window = TimeSpan.FromSeconds(rateLimiter.Window);
</span></span><span style=display:flex><span>                        options.QueueLimit = rateLimiter.QueueLimit;
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                // new code here:
</span></span><span style=display:flex><span>                .OnRejected = (context, _) =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                // inject Retry-After header (too much line wrapping, I know)
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> (context.Lease.TryGetMetadata(MetadataName.RetryAfter, 
</span></span><span style=display:flex><span>                    out <span style=font-weight:700>var</span> retryAfter)) {
</span></span><span style=display:flex><span>                    context.HttpContext.Response.Headers.RetryAfter =
</span></span><span style=display:flex><span>                        ((<span style=font-weight:700>int</span>) retryAfter.TotalSeconds).ToString();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                // <span style=font-weight:700>return</span> a different status code
</span></span><span style=display:flex><span>                context.HttpContext.Response.StatusCode = 
</span></span><span style=display:flex><span>                    StatusCodes.Status429TooManyRequests;
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> new();
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And that&rsquo;s all there is to it. I dropped the AspNetCoreRateLimiting dependency.
That is one great piece of software, and I am grateful to its author Stefan
Prodan and his contributors. As mentioned in <a href=/my-top-7-new-features-in-.net-7/>My Top 7 New Features in .NET
7</a>, they recently released a package that allows using Redis as a
rate-limiting backend. I might adopt it in the future.</p><p>Complete documentation for ASP.NET Core 7 rate-limiting middleware is available
<a href="https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-7.0">here</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/dotnet/>Dotnet</a></li><li><a href=https://nicolaiarocci.com/tags/rate-limiting/>Rate-Limiting</a></li><li><a href=https://nicolaiarocci.com/tags/programming/>Programming</a></li><li><a href=https://nicolaiarocci.com/tags/til/>Til</a></li></ul><nav class=paginav><a class=prev href=https://nicolaiarocci.com/book-review-stoner/><span class=title>« Prev</span><br><span>Book Review: Stoner</span>
</a><a class=next href=https://nicolaiarocci.com/latewood/><span class=title>Next »</span><br><span>Latewood</span></a></nav></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>