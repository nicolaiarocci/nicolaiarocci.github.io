<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Custom default values for not existing dictionary items (and a lesson learned) | Nicola Iarocci</title>
<meta name=keywords content="til,dotnet,programming"><meta name=description content="When dealing with dictionaries, a typical problem is when an operation attempts to retrieve an element using a key that does not exist in the dictionary. In .NET, a KeyNotFoundException is raised, and that&rsquo;s the desired behaviour in most circumstances. Sometimes, however, you know that your program will frequently try to retrieve keys that do not exist. In such cases, it is more efficient to use the TryGetValue method:
This method returns the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter is returned ([source][1])"><meta name=author content><link rel=canonical href=https://nicolaiarocci.com/custom-default-values-for-not-existing-dictionary-items-and-a-lesson-learned/><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Custom default values for not existing dictionary items (and a lesson learned)"><meta property="og:description" content="When dealing with dictionaries, a typical problem is when an operation attempts to retrieve an element using a key that does not exist in the dictionary. In .NET, a KeyNotFoundException is raised, and that&rsquo;s the desired behaviour in most circumstances. Sometimes, however, you know that your program will frequently try to retrieve keys that do not exist. In such cases, it is more efficient to use the TryGetValue method:
This method returns the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter is returned ([source][1])"><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/custom-default-values-for-not-existing-dictionary-items-and-a-lesson-learned/"><meta property="og:image" content="https://nicolaiarocci.com/images/avatar.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-06-11T07:05:25+01:00"><meta property="article:modified_time" content="2021-06-11T07:05:25+01:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nicolaiarocci.com/images/avatar.png"><meta name=twitter:title content="Custom default values for not existing dictionary items (and a lesson learned)"><meta name=twitter:description content="When dealing with dictionaries, a typical problem is when an operation attempts to retrieve an element using a key that does not exist in the dictionary. In .NET, a KeyNotFoundException is raised, and that&rsquo;s the desired behaviour in most circumstances. Sometimes, however, you know that your program will frequently try to retrieve keys that do not exist. In such cases, it is more efficient to use the TryGetValue method:
This method returns the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter is returned ([source][1])"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":3,"name":"Custom default values for not existing dictionary items (and a lesson learned)","item":"https://nicolaiarocci.com/custom-default-values-for-not-existing-dictionary-items-and-a-lesson-learned/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Custom default values for not existing dictionary items (and a lesson learned)","name":"Custom default values for not existing dictionary items (and a lesson learned)","description":"When dealing with dictionaries, a typical problem is when an operation attempts to retrieve an element using a key that does not exist in the dictionary. In .NET, a KeyNotFoundException is raised, and that\u0026rsquo;s the desired behaviour in most circumstances. Sometimes, however, you know that your program will frequently try to retrieve keys that do not exist. In such cases, it is more efficient to use the TryGetValue method:\nThis method returns the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter is returned ([source][1])","keywords":["til","dotnet","programming"],"articleBody":"When dealing with dictionaries, a typical problem is when an operation attempts to retrieve an element using a key that does not exist in the dictionary. In .NET, a KeyNotFoundException is raised, and that’s the desired behaviour in most circumstances. Sometimes, however, you know that your program will frequently try to retrieve keys that do not exist. In such cases, it is more efficient to use the TryGetValue method:\nThis method returns the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter is returned ([source][1])\nThe devil hides in details. TryGetValue returns the default value for the type of the value parameter. So, if you use TryGetValue to look into a dictionary of strings, null is returned on a missing key. That is probably ok in most cases. Howewer, if your logic requires a custom default value instead, then you are out of luck. You have to set it yourself on TryGetValue failure. A typical implementation would be:\nvar result = MyDictionary.TryGetValue(\"key\", var out value) ? value : \"not found\"; It is a minor annoyance but still a hassle. Our solution has always been a homemade GetValueOrDefault extension method, something like this:\npublic static TValue GetValueOrDefault (this IDictionary dictionary, TKey key, TValue defaultValue) { return dictionary.TryGetValue(key, var out value) ? value : defaultValue; } Usage:\nvar result = MyDictionary.GetValueOrDefault(\"key\", \"not found\"); We’ve been using it since forever, and we are still using it even in recent projects.\nToday, as I was looking at something only tangentially related, I learned that our extension method is obsolete, and it’s been for a while. NetStandard 2.1 and NetCore 2 added a new extension method to the official API. It’s called, you guessed it, [GetValueOrDefault][2]. It extends ÌReadOnlyDictionary, so it applies to all generic dictionaries, which is cool.\nWe could continue with our extension method. It has the advantage of working across all .NET platforms, not just recent ones. Implementations are likely similar, and there’s probably little (if any) performance difference (I am too lazy to compare). With NETCore (now NET5), APIs have not only acquired cross-platform compatibility and improved performance but they have also been expanded and amended, something often not very apparent. Not to me, at least.\nThe point I want to make here, I think, is that nothing is set in stone. Today’s little event shows how my knowledge becomes stagnant over time. Setting apart the time to learn new things is good, but acquired ones need sharping too.\n","wordCount":"424","inLanguage":"en","datePublished":"2021-06-11T07:05:25+01:00","dateModified":"2021-06-11T07:05:25+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/custom-default-values-for-not-existing-dictionary-items-and-a-lesson-learned/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Home (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title=newsletter><span>newsletter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Custom default values for not existing dictionary items (and a lesson learned)</h1><div class=post-meta><span title='2021-06-11 07:05:25 +0100 +0100'>June 11, 2021</span></div></header><div class=post-content><p>When dealing with dictionaries, a typical problem is when an operation attempts
to retrieve an element using a key that does not exist in the dictionary. In
.NET, a <code>KeyNotFoundException</code> is raised, and that&rsquo;s the desired behaviour in
most circumstances. Sometimes, however, you know that your program will
frequently try to retrieve keys that do not exist. In such cases, it is more
efficient to use the <code>TryGetValue</code> method:</p><blockquote><p>This method returns the value associated with the specified key, if the key
is found; otherwise, the default value for the type of the value parameter is
returned ([source][1])</p></blockquote><p>The devil hides in details. <code>TryGetValue</code> returns the default value for the
type of the <code>value</code> parameter. So, if you use <code>TryGetValue</code> to look into
a dictionary of strings, <code>null</code> is returned on a missing key. That is probably
ok in most cases. Howewer, if your logic requires a custom default value
instead, then you are out of luck. You have to set it yourself on <code>TryGetValue</code>
failure. A typical implementation would be:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>    <span style=font-weight:700>var</span> result = MyDictionary.TryGetValue(<span style=font-style:italic>&#34;key&#34;</span>, <span style=font-weight:700>var</span> out value) 
</span></span><span style=display:flex><span>        <span>?</span> value
</span></span><span style=display:flex><span>        : <span style=font-style:italic>&#34;not found&#34;</span>;
</span></span></code></pre></div><p>It is a minor annoyance but still a hassle. Our solution has always been
a homemade <code>GetValueOrDefault</code> extension method, something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>    public <span style=font-weight:700>static</span> TValue GetValueOrDefault&lt;TKey, TValue&gt; 
</span></span><span style=display:flex><span>        (this IDictionary&lt;TKey, TValue&gt; dictionary, TKey key, TValue defaultValue)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> dictionary.TryGetValue(key, <span style=font-weight:700>var</span> out value) 
</span></span><span style=display:flex><span>            <span>?</span> value
</span></span><span style=display:flex><span>            : defaultValue;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Usage:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>    <span style=font-weight:700>var</span> result = MyDictionary.GetValueOrDefault(<span style=font-style:italic>&#34;key&#34;</span>, <span style=font-style:italic>&#34;not found&#34;</span>);
</span></span></code></pre></div><p>We&rsquo;ve been using it since forever, and we are still using it even in recent
projects.</p><p>Today, as I was looking at something only tangentially related, I learned that
our extension method is obsolete, and it&rsquo;s been for a while. NetStandard
2.1 and NetCore 2 added a new extension method to the official API. It&rsquo;s
called, you guessed it, [<code>GetValueOrDefault</code>][2]. It extends
<code>ÌReadOnlyDictionary&lt;TKey, TValue></code>, so it applies to all generic dictionaries,
which is cool.</p><p>We could continue with our extension method. It has the advantage of working
across all .NET platforms, not just recent ones. Implementations are likely
similar, and there’s probably little (if any) performance difference (I am too
lazy to compare). With NETCore (now NET5), APIs have not only acquired
cross-platform compatibility and improved performance but they have also been
expanded and amended, something often not very apparent. Not to me, at least.</p><p>The point I want to make here, I think, is that nothing is set in stone. Today&rsquo;s
little event shows how my knowledge becomes stagnant over time. Setting apart
the time to learn new things is good, but acquired ones need sharping too.</p><i>Subscribe to my <a href=https://buttondown.email/nicolaiarocci>newsletter</a> or the <a href=/index.xml>RSS
feed</a>. Follow me on <a href=https://fosstodon.org/@nicola>Mastodon</a> or <a href=https://twitter.com/nicolaiarocci>X</a>.</div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/til/>til</a></li><li><a href=https://nicolaiarocci.com/tags/dotnet/>dotnet</a></li><li><a href=https://nicolaiarocci.com/tags/programming/>programming</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>