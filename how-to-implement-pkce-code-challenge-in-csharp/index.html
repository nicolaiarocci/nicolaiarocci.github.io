<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to implement a PKCE code challenge in C# | Nicola Iarocci</title>
<meta name=keywords content="til,pkce,dotnet,csharp,programming"><meta name=description content="Today&rsquo;s fun was implementing OAuth2&rsquo;s RFC 7636&rsquo;s PKCE (Proof Key for Code Exchange) in C#. It&rsquo;s relatively straightforward, but I decided to share my implementation should it be helpful to someone else out there.
PKCE is an extension to the Authorization Code flow to prevent CSRF and authorization code injection attacks. [..] It was originally designed to protect the authorization code flow in mobile apps, but its ability to prevent authorization code injection makes it useful for every type of OAuth client, even web apps that use client authentication (source)."><meta name=author content><link rel=canonical href=https://nicolaiarocci.com/how-to-implement-pkce-code-challenge-in-csharp/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to implement a PKCE code challenge in C#"><meta property="og:description" content="Today&rsquo;s fun was implementing OAuth2&rsquo;s RFC 7636&rsquo;s PKCE (Proof Key for Code Exchange) in C#. It&rsquo;s relatively straightforward, but I decided to share my implementation should it be helpful to someone else out there.
PKCE is an extension to the Authorization Code flow to prevent CSRF and authorization code injection attacks. [..] It was originally designed to protect the authorization code flow in mobile apps, but its ability to prevent authorization code injection makes it useful for every type of OAuth client, even web apps that use client authentication (source)."><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/how-to-implement-pkce-code-challenge-in-csharp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-17T18:28:14+01:00"><meta property="article:modified_time" content="2024-01-17T18:28:14+01:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to implement a PKCE code challenge in C#"><meta name=twitter:description content="Today&rsquo;s fun was implementing OAuth2&rsquo;s RFC 7636&rsquo;s PKCE (Proof Key for Code Exchange) in C#. It&rsquo;s relatively straightforward, but I decided to share my implementation should it be helpful to someone else out there.
PKCE is an extension to the Authorization Code flow to prevent CSRF and authorization code injection attacks. [..] It was originally designed to protect the authorization code flow in mobile apps, but its ability to prevent authorization code injection makes it useful for every type of OAuth client, even web apps that use client authentication (source)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"How to implement a PKCE code challenge in C#","item":"https://nicolaiarocci.com/how-to-implement-pkce-code-challenge-in-csharp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to implement a PKCE code challenge in C#","name":"How to implement a PKCE code challenge in C#","description":"Today\u0026rsquo;s fun was implementing OAuth2\u0026rsquo;s RFC 7636\u0026rsquo;s PKCE (Proof Key for Code Exchange) in C#. It\u0026rsquo;s relatively straightforward, but I decided to share my implementation should it be helpful to someone else out there.\nPKCE is an extension to the Authorization Code flow to prevent CSRF and authorization code injection attacks. [..] It was originally designed to protect the authorization code flow in mobile apps, but its ability to prevent authorization code injection makes it useful for every type of OAuth client, even web apps that use client authentication (source).","keywords":["til","pkce","dotnet","csharp","programming"],"articleBody":"Today’s fun was implementing OAuth2’s RFC 7636’s PKCE (Proof Key for Code Exchange) in C#. It’s relatively straightforward, but I decided to share my implementation should it be helpful to someone else out there.\nPKCE is an extension to the Authorization Code flow to prevent CSRF and authorization code injection attacks. [..] It was originally designed to protect the authorization code flow in mobile apps, but its ability to prevent authorization code injection makes it useful for every type of OAuth client, even web apps that use client authentication (source).\nIn a nutshell:\nThe client requests a single-use authorization code to an authorization server. In doing that, it includes a code_challenge with the request. The server responds with the authorization code if the client is recognized and authorized. The client requests an access token in exchange for the authorization code. It includes the code_verifier used to generate the original code_challenge; The server confirms that the verifier is the same one used to generate the code challenge; hence, the client is the same. Plenty of excellent documentation is online (like here.)\nI was interested in code_verifier and code_challenge generation. Here’s my implementation:\n/// /// Provides a randomly generating PKCE code verifier and it's corresponding code challenge. /// public static class Pkce { /// /// Generates a code_verifier and the corresponding code_challenge, as specified in the rfc-7636. /// /// See https://datatracker.ietf.org/doc/html/rfc7636#section-4.1 and https://datatracker.ietf.org/doc/html/rfc7636#section-4.2 public static (string code_challenge, string verifier) Generate(int size = 32) { using var rng = RandomNumberGenerator.Create(); var randomBytes = new byte[size]; rng.GetBytes(randomBytes); var verifier = Base64UrlEncode(randomBytes); var buffer = Encoding.UTF8.GetBytes(verifier); var hash = SHA256.Create().ComputeHash(buffer); var challenge = Base64UrlEncode(hash); return (challenge, verifier); } private static string Base64UrlEncode(byte[] data) =\u003e Convert.ToBase64String(data) .Replace(\"+\", \"-\") .Replace(\"/\", \"_\") .TrimEnd('='); } Usage is as simple as:\nvar (challenge, verifier) = Pkce.Generate(); In ASP.NET Core you don’t usually need to mess with PKCE as the framework supports it very transparently, but the project I’m working on right now is bare and to the bones, with no ASP.NET Core in sight, so I had to bring my own implementation. Fun stuff.\n","wordCount":"348","inLanguage":"en","datePublished":"2024-01-17T18:28:14+01:00","dateModified":"2024-01-17T18:28:14+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/how-to-implement-pkce-code-challenge-in-csharp/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title="mailing list"><span>mailing list</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">How to implement a PKCE code challenge in C#</h1><div class=post-meta><span title='2024-01-17 18:28:14 +0100 CET'>January 17, 2024</span></div></header><div class=post-content><p>Today&rsquo;s fun was implementing OAuth2&rsquo;s <a href=http://tools.ietf.org/html/rfc7636>RFC
7636</a>&rsquo;s PKCE (Proof Key for Code Exchange)
in C#. It&rsquo;s relatively straightforward, but I decided to share my implementation
should it be helpful to someone else out there.</p><blockquote><p>PKCE is an extension to the Authorization Code flow to prevent CSRF and
authorization code injection attacks. [..] It was originally designed to protect
the authorization code flow in mobile apps, but its ability to prevent
authorization code injection makes it useful for every type of OAuth client,
even web apps that use client authentication
(<a href=https://oauth.net/2/pkce/>source</a>).</p></blockquote><p>In a nutshell:</p><ol><li>The client requests a single-use authorization code to an authorization server. In doing that, it includes a <code>code_challenge</code> with the request.</li><li>The server responds with the authorization code if the client is recognized and authorized.</li><li>The client requests an access token in exchange for the authorization code. It includes the <code>code_verifier</code> used to generate the original <code>code_challenge</code>;</li><li>The server confirms that the verifier is the same one used to generate the code challenge; hence, the client is the same.</li></ol><p>Plenty of excellent documentation is online (like
<a href=https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce>here</a>.)</p><p>I was interested in <code>code_verifier</code> and <code>code_challenge</code> generation. Here&rsquo;s my implementation:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=font-style:italic>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=font-style:italic>/// Provides a randomly generating PKCE code verifier and it&#39;s corresponding code challenge.</span>
</span></span><span style=display:flex><span><span style=font-style:italic>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=font-weight:700>public</span> <span style=font-weight:700>static</span> <span style=font-weight:700>class</span> <span style=font-weight:700>Pkce</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=font-style:italic>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>/// Generates a code_verifier and the corresponding code_challenge, as specified in the rfc-7636.</span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>/// &lt;remarks&gt;See https://datatracker.ietf.org/doc/html/rfc7636#section-4.1 and https://datatracker.ietf.org/doc/html/rfc7636#section-4.2&lt;/remarks&gt;</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>public</span> <span style=font-weight:700>static</span> (<span>string</span> code_challenge, <span>string</span> verifier) Generate(<span>int</span> size = 32)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>using</span> <span style=font-weight:700>var</span> rng = RandomNumberGenerator.Create();
</span></span><span style=display:flex><span>        <span>var</span> randomBytes = <span style=font-weight:700>new</span> <span>byte</span>[size];
</span></span><span style=display:flex><span>        rng.GetBytes(randomBytes);
</span></span><span style=display:flex><span>        <span>var</span> verifier = Base64UrlEncode(randomBytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span>var</span> buffer = Encoding.UTF8.GetBytes(verifier);
</span></span><span style=display:flex><span>        <span>var</span> hash = SHA256.Create().ComputeHash(buffer);
</span></span><span style=display:flex><span>        <span>var</span> challenge = Base64UrlEncode(hash);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> (challenge, verifier);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>private</span> <span style=font-weight:700>static</span> <span>string</span> Base64UrlEncode(<span>byte</span>[] data) =&gt;
</span></span><span style=display:flex><span>        Convert.ToBase64String(data)
</span></span><span style=display:flex><span>            .Replace(<span style=font-style:italic>&#34;+&#34;</span>, <span style=font-style:italic>&#34;-&#34;</span>)
</span></span><span style=display:flex><span>            .Replace(<span style=font-style:italic>&#34;/&#34;</span>, <span style=font-style:italic>&#34;_&#34;</span>)
</span></span><span style=display:flex><span>            .TrimEnd(<span style=font-style:italic>&#39;=&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Usage is as simple as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span>var</span> (challenge, verifier) = Pkce.Generate();
</span></span></code></pre></div><p>In ASP.NET Core you don&rsquo;t usually need to mess with PKCE as the framework
supports it very transparently, but the project I&rsquo;m working on right now is bare
and to the bones, with no ASP.NET Core in sight, so I had to bring my own
implementation. Fun stuff.</p><i>Join the <a href=https://buttondown.email/nicolaiarocci>mailing list</a> or subscribe to the <a href=/index.xml>RSS
feed</a>. Follow me on <a href=https://fosstodon.org/@nicola>Mastodon</a> or <a href=https://twitter.com/nicolaiarocci>X</a>.</div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/til/>til</a></li><li><a href=https://nicolaiarocci.com/tags/pkce/>pkce</a></li><li><a href=https://nicolaiarocci.com/tags/dotnet/>dotnet</a></li><li><a href=https://nicolaiarocci.com/tags/csharp/>csharp</a></li><li><a href=https://nicolaiarocci.com/tags/programming/>programming</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>