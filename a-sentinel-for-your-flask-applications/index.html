<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How about a Sentinel for your Flask Application? | Nicola Iarocci</title>
<meta name=keywords content="eve,flask,oauth2,python"><meta name=description content="Flask-Sentinel is a OAuth2 Server implementation of the Resource Owner Password Credentials Grant pattern described in Section 1.3.3 of RFC 6749. It is powered by Flask-Oauthlib, Redis and MongoDB and is bundled as a Flask extension so it can be used to add OAuth2 capabilities to an existing application.
So what is the Resource Owner Password Credentials Grant pattern? According to the official RFC:
The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token."><meta name=author content="Nicola Iarocci"><link rel=canonical href=https://nicolaiarocci.com/a-sentinel-for-your-flask-applications/><link crossorigin=anonymous href=/assets/css/stylesheet.f0568d4df87da526a07cdd5f492b4a146e3fa93d5ee950200eaafb2bb50d6fd8.css integrity="sha256-8FaNTfh9pSagfN1fSStKFG4/qT1e6VAgDqr7K7UNb9g=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/apple-touch-icon.png><link rel=mask-icon href=https://nicolaiarocci.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How about a Sentinel for your Flask Application?"><meta property="og:description" content="Flask-Sentinel is a OAuth2 Server implementation of the Resource Owner Password Credentials Grant pattern described in Section 1.3.3 of RFC 6749. It is powered by Flask-Oauthlib, Redis and MongoDB and is bundled as a Flask extension so it can be used to add OAuth2 capabilities to an existing application.
So what is the Resource Owner Password Credentials Grant pattern? According to the official RFC:
The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token."><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/a-sentinel-for-your-flask-applications/"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-02-04T00:00:00+00:00"><meta property="article:modified_time" content="2015-02-04T00:00:00+00:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="How about a Sentinel for your Flask Application?"><meta name=twitter:description content="Flask-Sentinel is a OAuth2 Server implementation of the Resource Owner Password Credentials Grant pattern described in Section 1.3.3 of RFC 6749. It is powered by Flask-Oauthlib, Redis and MongoDB and is bundled as a Flask extension so it can be used to add OAuth2 capabilities to an existing application.
So what is the Resource Owner Password Credentials Grant pattern? According to the official RFC:
The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":3,"name":"How about a Sentinel for your Flask Application?","item":"https://nicolaiarocci.com/a-sentinel-for-your-flask-applications/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How about a Sentinel for your Flask Application?","name":"How about a Sentinel for your Flask Application?","description":"Flask-Sentinel is a OAuth2 Server implementation of the Resource Owner Password Credentials Grant pattern described in Section 1.3.3 of RFC 6749. It is powered by Flask-Oauthlib, Redis and MongoDB and is bundled as a Flask extension so it can be used to add OAuth2 capabilities to an existing application.\nSo what is the Resource Owner Password Credentials Grant pattern? According to the official RFC:\nThe resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token.","keywords":["eve","flask","oauth2","python"],"articleBody":"Flask-Sentinel is a OAuth2 Server implementation of the Resource Owner Password Credentials Grant pattern described in Section 1.3.3 of RFC 6749. It is powered by Flask-Oauthlib, Redis and MongoDB and is bundled as a Flask extension so it can be used to add OAuth2 capabilities to an existing application.\nSo what is the Resource Owner Password Credentials Grant pattern? According to the official RFC:\nThe resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token. The credentials should only be used when there is a high degree of trust between the resource owner and the client (e.g., the client is part of the device operating system or a highly privileged application).\nA typical use case would be when the remote API maintainer controls the client application. Say that you have a REST API being consumed by your own iOS, Android, WinPhone, desktop or web applications. Users register to your service by creating their accounts. Then, they consume the service using your applications.\nEven though this grant type requires direct client access to the resource owner credentials, the resource owner credentials are used for a single request and are exchanged for an access token. This grant type can eliminate the need for the client to store the resource owner credentials for future use, by exchanging the credentials with a long-lived access token or refresh token.\nSo let’s get back at the proprietary client scenario. The user has just installed the application on his/her device. On first run he/she is asked to provide his/her username and password. These are sent to the OAuth2 server through a SSL/TLS encrypted channel. If the user is registered for the service and the client id, which has also been sent along with the user credentials, is recognised, then the server sends back a valid access token. Otherwise responds with a 401 Unhautorized.\nFrom now on the application will only be using the access token for all requests until, eventually, the token expires. If that happens, the cycle repeats. Please note that in this scenario the client does not need to (and probably should not) store the username and/or password on the local cache. The User Credentials pattern usually relies on long lived tokens so asking again for username and password is not a big deal (you could also opt for permanent, revokable tokens.)\nFlask-Sentinel provides two endpoints: one for token creation which defaults to /oauth/token and is consumed by clients, and another for users and clients management, accessible at /oauth/management:\nNote that the password is hashed and salted on the server, so no plain password is stored on either sides of the channel.\nOnly existing users and recognised clients will be provided an access token. A typical token request would be as follows:\n$ curl -k -X POST -d \\ \"client_id=9qFbZD4udTzFVYo0u5UzkZX9iuzbdcJDRAquTfRk\u0026 grant_type=password\u0026 username=jonas\u0026 password=pass\" \\ /oauth/token And the response would be like so:\n{ \"access_token\": \"NYODXSR8KalTPnWUib47t5E8Pi8mo4\", \"token_type\": \"Bearer\", \"refresh_token\": \"s6L6OPL2bnKSRSbgQM3g0wbFkJB4ML\", \"scope\": \"\" } The client can now use the access token to access protected API endpoints:\n$ curl -k -H \\ \"Authorization:Bearer NYODXSR8KalTPnWUib47t5E8Pi8mo4\" \\ /endpoint 200 OK There are a number of configuration options of course, for example you can change the url of token and management endpoints, set token expiration, setup database connection, stuff like that. Redis is used to store active access tokens, allows for optimal performance.\nWhile you can use Flask-Sentinel to extend an existing API, you might want to instance it as a stand-alone Flask application to optimize for scalability. You would end up with a distributed network of three different (micro)services: the OAuth2 server, the resouces API with protected endpoints as needed, and the Redis instance bridging the two. Check out the project page on GitHub for details.\nOf course Flask-Sentinel integrates seamlessly with any Eve powered REST API. Check out the Eve-OAuth2 sample, a fork of the original Eve-Demo project with a couple protected endpoints and a static HTML page, also protected.\nThe project is very new and lacks a few little things, but I suspect it is already usable even at this stage. Enjoy!\nIf you want to get in touch, I am @nicolaiarocci on Twitter.\n","wordCount":"698","inLanguage":"en","datePublished":"2015-02-04T00:00:00Z","dateModified":"2015-02-04T00:00:00Z","author":{"@type":"Person","name":"Nicola Iarocci"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/a-sentinel-for-your-flask-applications/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Home (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=conferences><span>conferences</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">How about a Sentinel for your Flask Application?</h1><div class=post-meta><span title='2015-02-04 00:00:00 +0000 UTC'>February 4, 2015</span>&nbsp;·&nbsp;Nicola Iarocci</div></header><div class=post-content><p><a href=https://github.com/nicolaiarocci/flask-sentinel>Flask-Sentinel</a> is a OAuth2 Server implementation of the Resource Owner Password Credentials Grant pattern described in <a href=http://tools.ietf.org/html/rfc6749#section-1.3.3>Section 1.3.3 of RFC 6749</a>. It is powered by Flask-Oauthlib, Redis and MongoDB and is bundled as a Flask extension so it can be used to add OAuth2 capabilities to an existing application.</p><p>So what is the Resource Owner Password Credentials Grant pattern? According to the official RFC:</p><blockquote><p>The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token. The credentials should only be used when there is a high degree of trust between the resource owner and the client (e.g., the client is part of the device operating system or a highly privileged application).</p></blockquote><p>A typical use case would be when the remote API maintainer controls the client application. Say that you have a REST API being consumed by your own iOS, Android, WinPhone, desktop or web applications. Users register to your service by creating their accounts. Then, they consume the service using your applications.</p><blockquote><p>Even though this grant type requires direct client access to the resource owner credentials, the resource owner credentials are used for a single request and are exchanged for an access token. This grant type can eliminate the need for the client to store the resource owner credentials for future use, by exchanging the credentials with a long-lived access token or refresh token.</p></blockquote><p>So let’s get back at the proprietary client scenario. The user has just installed the application on his/her device. On first run he/she is asked to provide his/her username and password. These are sent to the OAuth2 server through a SSL/TLS encrypted channel. If the user is registered for the service and the client id, which has also been sent along with the user credentials, is recognised, then the server sends back a valid access token. Otherwise responds with a <code>401 Unhautorized</code>.</p><p>From now on the application will only be using the access token for all requests until, eventually, the token expires. If that happens, the cycle repeats. Please note that in this scenario the client does not need to (and probably should not) store the username and/or password on the local cache. The User Credentials pattern usually relies on long lived tokens so asking again for username and password is not a big deal (you could also opt for permanent, revokable tokens.)</p><p>Flask-Sentinel provides two endpoints: one for token creation which defaults to <code>/oauth/token</code> and is consumed by clients, and another for users and clients management, accessible at <code>/oauth/management</code>:</p><p>Note that the password is hashed and salted on the server, so no plain password is stored on either sides of the channel.</p><p>Only existing users and recognised clients will be provided an access token. A typical token request would be as follows:</p><pre><code>$ curl -k -X POST -d \
  &quot;client_id=9qFbZD4udTzFVYo0u5UzkZX9iuzbdcJDRAquTfRk&amp;
   grant_type=password&amp;
   username=jonas&amp;
   password=pass&quot; \
   &lt;api_url&gt;/oauth/token
</code></pre><p>And the response would be like so:</p><pre><code>{
    &quot;access_token&quot;: &quot;NYODXSR8KalTPnWUib47t5E8Pi8mo4&quot;, 
    &quot;token_type&quot;: &quot;Bearer&quot;, 
    &quot;refresh_token&quot;: &quot;s6L6OPL2bnKSRSbgQM3g0wbFkJB4ML&quot;, 
    &quot;scope&quot;: &quot;&quot;
}
</code></pre><p>The client can now use the access token to access protected API endpoints:</p><pre><code>$ curl -k -H \
  &quot;Authorization:Bearer NYODXSR8KalTPnWUib47t5E8Pi8mo4&quot; \
  &lt;api_url&gt;/endpoint

200 OK
</code></pre><p>There are a number of configuration options of course, for example you can change the url of token and management endpoints, set token expiration, setup database connection, stuff like that. Redis is used to store active access tokens, allows for optimal performance.</p><p>While you can use Flask-Sentinel to extend an existing API, you might want to instance it as a stand-alone Flask application to optimize for scalability. You would end up with a distributed network of three different (micro)services: the OAuth2 server, the resouces API with protected endpoints as needed, and the Redis instance bridging the two. Check out the <a href=https://github.com/nicolaiarocci/flask-sentinel>project page</a> on GitHub for details.</p><p>Of course Flask-Sentinel integrates seamlessly with any <a href=http://python-eve.org>Eve</a> powered REST API. Check out the <a href=https://github.com/nicolaiarocci/eve-oauth2>Eve-OAuth2</a> sample, a fork of the original Eve-Demo project with a couple protected endpoints and a static HTML page, also protected.</p><p>The project is very new and lacks a few little things, but I suspect it is already usable even at this stage. Enjoy!</p><p>If you want to get in touch, I am <a href=http://twitter.com/nicolaiarocci>@nicolaiarocci</a> on Twitter.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/eve/>eve</a></li><li><a href=https://nicolaiarocci.com/tags/flask/>flask</a></li><li><a href=https://nicolaiarocci.com/tags/oauth2/>oauth2</a></li><li><a href=https://nicolaiarocci.com/tags/python/>python</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://nicolaiarocci.com>Nicola Iarocci</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>