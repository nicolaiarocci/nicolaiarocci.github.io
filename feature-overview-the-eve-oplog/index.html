<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Feature Overview: The Eve OpLog | Nicola Iarocci</title>
<meta name=keywords content="eve,python"><meta name=description content="The operations log or OpLog is a new Eve feature that I’m currently developing on the oplog experimental branch. It’s supposed to help in addressing a subtle issue that we’ve been dealing with, but I believe it can also emerge as a very useful all-around tool. I am posting about it in the hope of gathering some feedback from Eve contributors and users, so that I can better pinpoint design and implementation before I merge it to the main development branch.
What is the OpLog?
The OpLog is a special resource that keeps a record of operations that modify the data stored by the API. Every POST, PATCH, PUT and DELETE operation can eventually be recorded by the oplog.
At its core the oplog is simply a server log, something that’s always been on the Eve roadmap. What makes it a little bit different is its ability to be exposed as a read-only API endpoint. This would in turn allow clients to query it as they would with any other standard endpoint."><meta name=author content="Nicola Iarocci"><link rel=canonical href=https://nicolaiarocci.com/feature-overview-the-eve-oplog/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Feature Overview: The Eve OpLog"><meta property="og:description" content="The operations log or OpLog is a new Eve feature that I’m currently developing on the oplog experimental branch. It’s supposed to help in addressing a subtle issue that we’ve been dealing with, but I believe it can also emerge as a very useful all-around tool. I am posting about it in the hope of gathering some feedback from Eve contributors and users, so that I can better pinpoint design and implementation before I merge it to the main development branch.
What is the OpLog?
The OpLog is a special resource that keeps a record of operations that modify the data stored by the API. Every POST, PATCH, PUT and DELETE operation can eventually be recorded by the oplog.
At its core the oplog is simply a server log, something that’s always been on the Eve roadmap. What makes it a little bit different is its ability to be exposed as a read-only API endpoint. This would in turn allow clients to query it as they would with any other standard endpoint."><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/feature-overview-the-eve-oplog/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-10-06T00:00:00+00:00"><meta property="article:modified_time" content="2014-10-06T00:00:00+00:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="Feature Overview: The Eve OpLog"><meta name=twitter:description content="The operations log or OpLog is a new Eve feature that I’m currently developing on the oplog experimental branch. It’s supposed to help in addressing a subtle issue that we’ve been dealing with, but I believe it can also emerge as a very useful all-around tool. I am posting about it in the hope of gathering some feedback from Eve contributors and users, so that I can better pinpoint design and implementation before I merge it to the main development branch.
What is the OpLog?
The OpLog is a special resource that keeps a record of operations that modify the data stored by the API. Every POST, PATCH, PUT and DELETE operation can eventually be recorded by the oplog.
At its core the oplog is simply a server log, something that’s always been on the Eve roadmap. What makes it a little bit different is its ability to be exposed as a read-only API endpoint. This would in turn allow clients to query it as they would with any other standard endpoint."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":2,"name":"Feature Overview: The Eve OpLog","item":"https://nicolaiarocci.com/feature-overview-the-eve-oplog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Feature Overview: The Eve OpLog","name":"Feature Overview: The Eve OpLog","description":"The operations log or OpLog is a new Eve feature that I’m currently developing on the oplog experimental branch. It’s supposed to help in addressing a subtle issue that we’ve been dealing with, but I believe it can also emerge as a very useful all-around tool. I am posting about it in the hope of gathering some feedback from Eve contributors and users, so that I can better pinpoint design and implementation before I merge it to the main development branch.\nWhat is the OpLog? The OpLog is a special resource that keeps a record of operations that modify the data stored by the API. Every POST, PATCH, PUT and DELETE operation can eventually be recorded by the oplog.\nAt its core the oplog is simply a server log, something that’s always been on the Eve roadmap. What makes it a little bit different is its ability to be exposed as a read-only API endpoint. This would in turn allow clients to query it as they would with any other standard endpoint.\n","keywords":["eve","python"],"articleBody":"The operations log or OpLog is a new Eve feature that I’m currently developing on the oplog experimental branch. It’s supposed to help in addressing a subtle issue that we’ve been dealing with, but I believe it can also emerge as a very useful all-around tool. I am posting about it in the hope of gathering some feedback from Eve contributors and users, so that I can better pinpoint design and implementation before I merge it to the main development branch.\nWhat is the OpLog? The OpLog is a special resource that keeps a record of operations that modify the data stored by the API. Every POST, PATCH, PUT and DELETE operation can eventually be recorded by the oplog.\nAt its core the oplog is simply a server log, something that’s always been on the Eve roadmap. What makes it a little bit different is its ability to be exposed as a read-only API endpoint. This would in turn allow clients to query it as they would with any other standard endpoint.\nEvery oplog entry contains few important informations about the document\ninvolved with the edit operation:\nURL of the endpoint hit by the operation. Kind of operation performed. Unique ID of the document. Date when the document was updated. Date when the document as created. User token, if User Restricted Resource Access is enabled for the endpoint Like any other API-maintained documents, oplog entries also contain:\nUnique ID ETag HATEOAS meta fields, if enabled. A typical oplog entry would look something like this:\n{ \"o\": \"DELETE\", \"r\": \"people\", \"i\": \"542d118938345b614ea75b3c\", \"_updated\": \"Fri, 03 Oct 2014 08:16:52 GMT\", \"_created\": \"Fri, 03 Oct 2014 08:16:52 GMT\", \"_id\": \"542e5b7438345b6dadf95ba5\", \"_etag\": \"e17218fbca41cb0ee6a5a5933fb9ee4f4ca7e5d6\" \"_links\": {...}, } To save a little storing space field names have been shortened when possible (what can I say, I’m a MongoDB guy): o stands for operation, r stands for resource, i stands for unique ID and c stands for changes. Other keys are defined by the configuration settings, and their default names are shown here.\nHow is the oplog operated? Three new settings keywords are available:\nOPLOG\nSets the oplog name and defaults to oplog. This is the name of the collection on the database and also the default url for the oplog endpoint.\nOPLOG_METHODS\nA list of HTTP methods for which oplog entries are to be recorded. Defaults to ['DELETE'].\nOPLOG_ENDPOINT\nSet it to True if an oplog endpoint should be made available by the API. Defaults to False.\nOPLOG_AUDIT\nIf enabled, IP addresses and changes introduced with PATCH and PUT methods are also logged. Defaults to True.\nSo by default the oplog is stored on a conveniently named oplog collection, it only stores informations about deleted documents.\nSince the eventual oplog endpoint is a standard API endpoint, if it is enabled the API maintainer can also fiddle with the endpoint settings as he/she would do with any other Eve endpoint. This allows for setting custom authentication (you probably want this resource to be only accessible for administrative purposes), changing the url, etc. Just add an oplog entry to the API domain, like so:\n'oplog': { 'url': 'log', 'auth': my_custom_auth_class, 'datasource': {'source': 'myapilog'} } Note that while you can change most settings, the endpoint will always be read-only, so setting either resource_methods or item_methods to something else than ['GET'] will serve no purpose. Also, unless you need to do so, adding an oplog entry to the API domain is not required as it will be added automatically for you.\nWhy the OpLog? Clients have always been able to retrieve changes by simply querying an endpoint with a If-Modified-Since request. So why do we need an operations log? Of course because server-side logging is cool, and so is auditing, but it’s not only about that.\nSingle entry point for all API updates From the client perspective and for most use cases logging inserted, edited and replaced documents is probably a waste of both space and time, and this is the main reason why only DELETE operations are logged by default. However, I believe there are scenarios where remote access to a full activity log can be useful.\nImagine an API which is accessed by multiple apps (say phone, tablet, web and desktop applications) and all of them need to stay in sync with each other and the server. Instead of hitting every single endpoint with a IMS request they could just access the oplog. That’s a single request vs several, and since the oplog itself is a standard API endpoint, they could also perform IMS requests against it for optimal gains:\nServer, please send me all the changes occurred to the API since my last access. Sincerely, Your Client.\nAgain this is not always the best approach a client could take. Sometimes it is probably better to only query for changes when they are really needed, but it seems cool to have both approaches available (and remember, the oplog endpoint is disabled by default).\nFixing 304s And then there are deleted documents which are a completely different beast. With no oplog we would have no way to tell if and when any document has been deleted, let alone inform clients about that. Actually, there is an open ticket precisely about this, and it’s been sitting there for a while.\nWhen a If-Modified-Since request is received, the API is expected to respond with a 304 Not Modified status if no changes occurred, so that clients can conveniently fallback to cached data. Up to version 0.4 (the official release at the time of this writing) Eve has been doing exactly that, with one caveat: missing documents were being ignored as, in the contest of the IMS request, there was no way to know about them.\nThe operations log will allow Eve powered APIs to take deleted documents into account, returning perfectly proper 304 codes as needed. The impact on performance should be minimal as we will only query the oplog when and if no changes have been detected on the target collection.\nThis solves only one half of the problem however. What happens when a IMS request comes in and deleted documents are found in the backlog? How do we report them back to the client? Three options come to mind which would address this scenario:\nRespond with a 200 OK and a the usual “changes since IMS date” payload, which might happen to be empty if only deletions occurred in the time window. The client can then go and query the oplog endpoint with the same IMS date, finally getting the list of deleted documents IDs.\nInclude deleted documents IDs in the standard payload (within the _items list), maybe with a deleted status tag. This status tag is something new though, and for consistency we should probably add it to other objects in the payload.\nAdd support for a new _deleted meta field in resource payloads. When deleted documents are spotted in the backlog the response payload will include them in their own list. Something like this:\nFirst option is so bad I should probably not be listing it at all. It would take two roundtrips to get the whole update down. Also, it would kind of force API maintainers to open the oplog endpoint to their clients.\nI’m not convinced #2 would be a good idea either, as objects in the items list would not be homogeneous anymore and we would have to add support for a new meta field anyway (the status tag).\nOption #3 on the other hand looks quite good to me. It does not require multiple requests to handle the case of deleted documents on IMS requests, and it is still easy and clean for clients to process. I am going to go with #3 unless feedback is negative and for good reasons, so let your opinion be heard.\nClosing concerns I am slightly concerned about the performance impact, not so much on IMS requests but rather on write operations, especially when a complete, all-operations log is being recorded.\nIn MongoDB world OpLog is probably an ideal candidate for a capped collection. I’m not entirely convinced about that though, as by its nature a capped collection is bound to lose data over time, which again might lead to inaccurate 304 handling.\nI am not implementing the OpLog at the data layer level however. It is a business layer feature to let other engines take advantage of it. Nothing prevents the MongoDB admin from setting the oplog as a capped collection anyway. Also, keep in mind that like all other resources maintained by the API, indexes are not handled by Eve itself so you will have to do your homework in that field too.\nSo here you have it. I’m currently done on both configuration and logging parts and will be working on 304 handling and response payloads in the coming days so that all of this can be included with next version 0.5. Be warned that at the moment the develop branch has no support for IMS requests on resource endpoints. It’s been disabled to avoid providing clients with inaccurate responses (see the ticket above).\nIf you have any comment or feedback to provide, please let me know in the comments below. I’d really appreciate that.\nPS. In case you are wondering yes, the Eve OpLog is heavily inspired by the awesome MongoDB OpLog.\n","wordCount":"1559","inLanguage":"en","datePublished":"2014-10-06T00:00:00Z","dateModified":"2014-10-06T00:00:00Z","author":{"@type":"Person","name":"Nicola Iarocci"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/feature-overview-the-eve-oplog/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Nicola Iarocci (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Nicola Iarocci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/about/ title=about><span>about</span></a></li><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title="mailing list"><span>mailing list</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Feature Overview: The Eve OpLog</h1><div class=post-meta><span title='2014-10-06 00:00:00 +0000 UTC'>October 6, 2014</span>&nbsp;·&nbsp;Nicola Iarocci</div></header><div class=post-content><p>The operations log or OpLog is a new <a href=http://python-eve.org>Eve</a> feature that I’m currently developing on the <a href=https://github.com/nicolaiarocci/eve/tree/oplog><code>oplog</code></a> experimental branch. It’s supposed to help in addressing a subtle issue that we’ve been dealing with, but I believe it can also emerge as a very useful all-around tool. I am posting about it in the hope of gathering some feedback from Eve contributors and users, so that I can better pinpoint design and implementation before I merge it to the main development branch.</p><h2 id=what-is-the-oplog>What is the OpLog?<a hidden class=anchor aria-hidden=true href=#what-is-the-oplog>#</a></h2><p>The OpLog is a special resource that keeps a record of operations that modify the data stored by the API. Every <code>POST</code>, <code>PATCH</code>, <code>PUT</code> and <code>DELETE</code> operation can eventually be recorded by the oplog.</p><p>At its core the oplog is simply a server log, something that’s always been on the Eve roadmap. What makes it a little bit different is its ability to be exposed as a read-only API endpoint. This would in turn allow clients to query it as they would with any other standard endpoint.</p><p>Every oplog entry contains few important informations about the document</p><p>involved with the edit operation:</p><ul><li>URL of the endpoint hit by the operation.</li><li>Kind of operation performed.</li><li>Unique ID of the document.</li><li>Date when the document was updated.</li><li>Date when the document as created.</li><li>User token, if <a href=http://python-eve.org/authentication.html#user-restricted-resource-access>User Restricted Resource Access</a> is enabled for the endpoint</li></ul><p>Like any other API-maintained documents, oplog entries also contain:</p><ul><li>Unique ID</li><li>ETag</li><li><a href=http://python-eve.org/features.html#hateoas>HATEOAS</a> meta fields, if enabled.</li></ul><p>A typical oplog entry would look something like this:</p><pre><code>{
    &quot;o&quot;: &quot;DELETE&quot;, 
    &quot;r&quot;: &quot;people&quot;, 
    &quot;i&quot;: &quot;542d118938345b614ea75b3c&quot;,
    &quot;_updated&quot;: &quot;Fri, 03 Oct 2014 08:16:52 GMT&quot;, 
    &quot;_created&quot;: &quot;Fri, 03 Oct 2014 08:16:52 GMT&quot;,
    &quot;_id&quot;: &quot;542e5b7438345b6dadf95ba5&quot;, 
    &quot;_etag&quot;: &quot;e17218fbca41cb0ee6a5a5933fb9ee4f4ca7e5d6&quot;
    &quot;_links&quot;: {...},
}
</code></pre><p>To save a little storing space field names have been shortened when possible (what can I say, I’m a MongoDB guy): <code>o</code> stands for operation, <code>r</code> stands for resource, <code>i</code> stands for unique ID and <code>c</code> stands for changes. Other keys are defined by the configuration settings, and their default names are shown here.</p><h2 id=how-is-the-oplog-operated>How is the oplog operated?<a hidden class=anchor aria-hidden=true href=#how-is-the-oplog-operated>#</a></h2><p>Three new settings keywords are available:</p><ul><li><p><code>OPLOG</code></p><p>Sets the oplog name and defaults to <code>oplog</code>. This is the name of the collection on the database and also the default url for the oplog endpoint.</p></li><li><p><code>OPLOG_METHODS</code></p><p>A list of HTTP methods for which oplog entries are to be recorded. Defaults to <code>['DELETE']</code>.</p></li><li><p><code>OPLOG_ENDPOINT</code></p><p>Set it to <code>True</code> if an oplog endpoint should be made available by the API. Defaults to <code>False</code>.</p></li><li><p><code>OPLOG_AUDIT</code></p><p>If enabled, IP addresses and changes introduced with <code>PATCH</code> and <code>PUT</code> methods are also logged. Defaults to <code>True</code>.</p></li></ul><p>So by default the oplog is stored on a conveniently named <code>oplog</code> collection, it only stores informations about deleted documents.</p><p>Since the eventual oplog endpoint is a standard API endpoint, if it is enabled the API maintainer can also fiddle with the endpoint settings as he/she would do with any other Eve endpoint. This allows for setting custom authentication (you probably want this resource to be only accessible for administrative purposes), changing the url, etc. Just add an <code>oplog</code> entry to the <a href=http://python-eve.org/config#domain-configuration>API domain</a>, like so:</p><pre><code>'oplog': {
    'url': 'log',
    'auth': my_custom_auth_class,
    'datasource': {'source': 'myapilog'}
}
</code></pre><p>Note that while you can change most settings, the endpoint will always be read-only, so setting either <code>resource_methods</code> or <code>item_methods</code> to something else than <code>['GET']</code> will serve no purpose. Also, unless you need to do so, adding an oplog entry to the API domain is not required as it will be added automatically for you.</p><h2 id=why-the-oplog>Why the OpLog?<a hidden class=anchor aria-hidden=true href=#why-the-oplog>#</a></h2><p>Clients have always been able to retrieve changes by simply querying an endpoint with a <code>If-Modified-Since</code> request. So why do we need an operations log? Of course because server-side logging is cool, and so is auditing, but it’s not only about that.</p><h3 id=single-entry-point-for-all-api-updates>Single entry point for all API updates<a hidden class=anchor aria-hidden=true href=#single-entry-point-for-all-api-updates>#</a></h3><p>From the client perspective and for most use cases logging inserted, edited and replaced documents is probably a waste of both space and time, and this is the main reason why only <code>DELETE</code> operations are logged by default. However, I believe there are scenarios where remote access to a full activity log can be useful.</p><p>Imagine an API which is accessed by multiple apps (say phone, tablet, web and desktop applications) and all of them need to stay in sync with each other and the server. Instead of hitting every single endpoint with a <code>IMS</code> request they could just access the oplog. That’s a single request vs several, and since the oplog itself is a standard API endpoint, they could also perform <code>IMS</code> requests against it for optimal gains:</p><blockquote><p>Server, please send me all the changes occurred to the API since my last access. Sincerely, Your Client.</p></blockquote><p>Again this is not always the best approach a client could take. Sometimes it is probably better to only query for changes when they are really needed, but it seems cool to have both approaches available (and remember, the oplog endpoint is disabled by default).</p><h3 id=fixing-304s>Fixing 304s<a hidden class=anchor aria-hidden=true href=#fixing-304s>#</a></h3><p>And then there are deleted documents which are a completely different beast. With no oplog we would have no way to tell if and when any document has been deleted, let alone inform clients about that. Actually, there is an <a href=https://github.com/nicolaiarocci/eve/issues/334>open ticket</a> precisely about this, and it’s been sitting there for a while.</p><p>When a <code>If-Modified-Since</code> request is received, the API is expected to respond with a <code>304 Not Modified</code> status if no changes occurred, so that clients can conveniently fallback to cached data. Up to version 0.4 (the official release at the time of this writing) Eve has been doing exactly that, with one caveat: missing documents were being ignored as, in the contest of the <code>IMS</code> request, there was no way to know about them.</p><p>The operations log will allow Eve powered APIs to take deleted documents into account, returning perfectly proper <code>304</code> codes as needed. The impact on performance should be minimal as we will only query the oplog when and if no changes have been detected on the target collection.</p><p>This solves only one half of the problem however. What happens when a <code>IMS</code> request comes in and deleted documents are found in the backlog? How do we report them back to the client? Three options come to mind which would address this scenario:</p><ol><li><p>Respond with a <code>200 OK</code> and a the usual “changes since <code>IMS</code> date” payload, which might happen to be empty if only deletions occurred in the time window. The client can then go and query the oplog endpoint with the same <code>IMS</code> date, finally getting the list of deleted documents IDs.</p></li><li><p>Include deleted documents IDs in the standard payload (within the <code>_items</code> list), maybe with a <code>deleted</code> status tag. This status tag is something new though, and for consistency we should probably add it to other objects in the payload.</p></li><li><p>Add support for a new <code>_deleted</code> meta field in resource payloads. When deleted documents are spotted in the backlog the response payload will include them in their own list. Something like this:</p></li></ol><p>First option is so bad I should probably not be listing it at all. It would take two roundtrips to get the whole update down. Also, it would kind of force API maintainers to open the oplog endpoint to their clients.</p><p>I’m not convinced #2 would be a good idea either, as objects in the items list would not be homogeneous anymore and we would have to add support for a new meta field anyway (the status tag).</p><p>Option #3 on the other hand looks quite good to me. It does not require multiple requests to handle the case of deleted documents on <code>IMS</code> requests, and it is still easy and clean for clients to process. I am going to go with #3 unless feedback is negative and for good reasons, so let your opinion be heard.</p><h2 id=closing-concerns>Closing concerns<a hidden class=anchor aria-hidden=true href=#closing-concerns>#</a></h2><p>I am slightly concerned about the performance impact, not so much on <code>IMS</code> requests but rather on write operations, especially when a complete, all-operations log is being recorded.</p><p>In MongoDB world OpLog is probably an ideal candidate for a <a href=http://docs.mongodb.org/manual/core/capped-collections/>capped collection</a>. I’m not entirely convinced about that though, as by its nature a capped collection is bound to lose data over time, which again might lead to inaccurate <code>304</code> handling.</p><p>I am not implementing the OpLog at the data layer level however. It is a business layer feature to let other engines take advantage of it. Nothing prevents the MongoDB admin from setting the <code>oplog</code> as a capped collection anyway. Also, keep in mind that like all other resources maintained by the API, indexes are not handled by Eve itself so you will have to do your homework in that field too.</p><p>So here you have it. I’m currently done on both configuration and logging parts and will be working on <code>304</code> handling and response payloads in the coming days so that all of this can be included with next version 0.5. Be warned that at the moment the <code>develop</code> branch has no support for <code>IMS</code> requests on resource endpoints. It’s been disabled to avoid providing clients with inaccurate responses (see the ticket above).</p><p>If you have any comment or feedback to provide, please let me know in the comments below. I’d really appreciate that.</p><p>PS. In case you are wondering yes, the Eve OpLog is heavily inspired by the awesome <a href=http://docs.mongodb.org/manual/core/replica-set-oplog/>MongoDB OpLog</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/eve/>eve</a></li><li><a href=https://nicolaiarocci.com/tags/python/>python</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>