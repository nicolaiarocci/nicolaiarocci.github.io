<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Validating user objects with Cerberus | Nicola Iarocci</title>
<meta name=keywords content="cerberus,python"><meta name=description content="People keep telling me that they want to validate class and instance attributes (object properties) with Cerberus. While it certainly wasn’t conceived with that goal in mind, it is actually very possible to leverage both the Python data model and Cerberus extensibility to achieve object validation.
Nuts & Bolts Let’s say that we have a simple class:
>>> class Person(object): ... pass We create a Person instance and add a few properties and values:"><meta name=author content="Nicola Iarocci"><link rel=canonical href=https://nicolaiarocci.com/validating-user-objects-cerberus/><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicolaiarocci.com/images/favicon16x16.ico><link rel=icon type=image/png sizes=32x32 href=https://nicolaiarocci.com/images/favicon32x32.ico><link rel=apple-touch-icon href=https://nicolaiarocci.com/images/favicon.ico><link rel=mask-icon href=https://nicolaiarocci.com/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Validating user objects with Cerberus"><meta property="og:description" content="People keep telling me that they want to validate class and instance attributes (object properties) with Cerberus. While it certainly wasn’t conceived with that goal in mind, it is actually very possible to leverage both the Python data model and Cerberus extensibility to achieve object validation.
Nuts & Bolts Let’s say that we have a simple class:
>>> class Person(object): ... pass We create a Person instance and add a few properties and values:"><meta property="og:type" content="article"><meta property="og:url" content="https://nicolaiarocci.com/validating-user-objects-cerberus/"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-01-05T00:00:00+00:00"><meta property="article:modified_time" content="2015-01-05T00:00:00+00:00"><meta property="og:site_name" content="Nicola Iarocci"><meta name=twitter:card content="summary"><meta name=twitter:title content="Validating user objects with Cerberus"><meta name=twitter:description content="People keep telling me that they want to validate class and instance attributes (object properties) with Cerberus. While it certainly wasn’t conceived with that goal in mind, it is actually very possible to leverage both the Python data model and Cerberus extensibility to achieve object validation.
Nuts & Bolts Let’s say that we have a simple class:
>>> class Person(object): ... pass We create a Person instance and add a few properties and values:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nicolaiarocci.com/post/"},{"@type":"ListItem","position":3,"name":"Validating user objects with Cerberus","item":"https://nicolaiarocci.com/validating-user-objects-cerberus/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Validating user objects with Cerberus","name":"Validating user objects with Cerberus","description":"People keep telling me that they want to validate class and instance attributes (object properties) with Cerberus. While it certainly wasn’t conceived with that goal in mind, it is actually very possible to leverage both the Python data model and Cerberus extensibility to achieve object validation.\nNuts \u0026amp; Bolts Let’s say that we have a simple class:\n\u0026gt;\u0026gt;\u0026gt; class Person(object): ... pass We create a Person instance and add a few properties and values:","keywords":["cerberus","python"],"articleBody":"People keep telling me that they want to validate class and instance attributes (object properties) with Cerberus. While it certainly wasn’t conceived with that goal in mind, it is actually very possible to leverage both the Python data model and Cerberus extensibility to achieve object validation.\nNuts \u0026 Bolts Let’s say that we have a simple class:\n\u003e\u003e\u003e class Person(object): ... pass We create a Person instance and add a few properties and values:\n\u003e\u003e\u003e p = Person() \u003e\u003e\u003e p.name = \"bill\" \u003e\u003e\u003e p.age = 44 Now let’s instance a Cerberus Validator and set up some validation rules for it:\n\u003e\u003e\u003e from Cerberus import Validator \u003e\u003e\u003e schema = { ... 'name': {'type': 'string'}, ... 'age': {'type': 'integer', 'min': 0} ... } \u003e\u003e\u003e v = Validator(schema) As you probably know already, all Python user objects have a __dict__ magic method which exposes class and instance attributes as a dictionary. This means that we can also query our class like this:\n\u003e\u003e\u003e p.__dict__ {'name': 'bill', 'age': 44} \u003e\u003e\u003e p.__dict__['age'] 44 You see where we are going with this: we can exploit the __dict__ method in order to let Cerberus perform validation on our object:\n\u003e\u003e\u003e v.validate(p.__dict__) True Validation succeeds because current attribute values do not break any rule. However, if we break the rules we do get what we deserve:\n\u003e\u003e\u003e p.age = -1 \u003e\u003e\u003e v.validate(p.__dict__) False \u003e\u003e\u003e v.errors {'age': 'min value is 0'} This works, but is somewhat clumsy. We can do better.\nA Custom Object Validator How about letting the Validator do the work for us? We could subclass the standard Validator and extend it to natively support object validation.\n\u003e\u003e\u003e class ObjectValidator(Validator): ... def validate_object(self, obj): ... return self.validate(obj.__dict__) ... \u003e\u003e\u003e v = ObjectValidator(schema) \u003e\u003e\u003e v.validate_object(p) False \u003e\u003e\u003e v.errors {'age': 'min value is 0'} \u003e\u003e\u003e p.age = 44 \u003e\u003e\u003e v.validate_object(p) True Much better. But what happens if we add a new property and then validate the object?\n\u003e\u003e\u003e p.lastname = 'white' \u003e\u003e\u003e v.validate_object(p) False \u003e\u003e\u003e v.errors {'lastname': 'unknown field'} Validation fails because by default unknown fields are not allowed. This might not be the desired behaviour. If this is the case, we simply need to update the helper method in our custom validator class:\n\u003e\u003e\u003e class ObjectValidator(Validator): ... def validate_object(self, obj): ... self.allow_unknown = True ... return self.validate(obj.__dict__) \u003e\u003e\u003e v.validate_object(p) True By setting allow_unknown to True we let unknown fields be ignored by validation. If we are not concerned by state changes between calls we might conveniently choose to move the setting of allow_unknown to the __init__ method so it gets executed only once.\nLooks good so far. We can validate simple objects. But what about complex ones like those exposing other objects as attributes? This is going to require some more tinkering.\nValidating Complex Objects It would be super handy if we could add support for an object data type and then provide a validation schema for it, like we already do with the dict and list types. A revised validation schema would then look like this:\n\u003e\u003e\u003e schema = { ... 'name': {'type': 'string'}, ... 'age': {'type': 'integer', 'min': 0}, ... 'address': { ... 'type': 'object', 'schema': { ... 'street': {'type': 'string'}, ... 'zip': {'type': 'integer'} ... } ... } ... } We could then validate it like so:\n\u003e\u003e\u003e class Address ... pass \u003e\u003e\u003e addr = Address() \u003e\u003e\u003e addr.street = 'Lexington' \u003e\u003e\u003e addr.zip = 50238 \u003e\u003e\u003e p.address = addr \u003e\u003e\u003e v.validate_object(p) True \u003e\u003e\u003e p.address.zip = 'not a number' \u003e\u003e\u003e v.validate_object(p) False \u003e\u003e\u003e v.errors {'address': {'zip': 'must be of integer type'}} It turns out this is also very achievable. We can leverage Cerberus data type extensibility model to add support for the object type. Then it is just a matter of handling the new type when validating the schema rule. I’m not going into details here but you can check Validating complex objects with Cerberus, a trivial implementation I posted as a GitHub gist.\nClosing note You might be wondering why don’t I add object validation to Cerberus core. Actually, I don’t rule out this possibility but see I like to keep tools as simple, targeted and focused as possible. Besides, there are other object validation tools out there, so adding a new flavour does not seem very useful to me (but let me know if you feel otherwise.) Though as we have seen, if you want to validate user objects with Cerberus, you can do that easily enough.\nIf you want to get in touch, I am @nicolaiarocci on Twitter.\n","wordCount":"744","inLanguage":"en","datePublished":"2015-01-05T00:00:00Z","dateModified":"2015-01-05T00:00:00Z","author":{"@type":"Person","name":"Nicola Iarocci"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicolaiarocci.com/validating-user-objects-cerberus/"},"publisher":{"@type":"Organization","name":"Nicola Iarocci","logo":{"@type":"ImageObject","url":"https://nicolaiarocci.com/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicolaiarocci.com accesskey=h title="Home (Alt + H)"><img src=https://nicolaiarocci.com/images/avatar.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicolaiarocci.com/opensource/ title=code><span>code</span></a></li><li><a href=https://nicolaiarocci.com/speaking/ title=speaking><span>speaking</span></a></li><li><a href=https://nicolaiarocci.com/books-i-have-read/ title=library><span>library</span></a></li><li><a href=https://buttondown.email/nicolaiarocci title=newsletter><span>newsletter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nicolaiarocci.com/index.xml title=rss><span>rss</span></a></li><li><a href=https://nicolaiarocci.com/archives/ title=archive><span>archive</span></a></li><li><a href=https://nicolaiarocci.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Validating user objects with Cerberus</h1><div class=post-meta><span title='2015-01-05 00:00:00 +0000 UTC'>January 5, 2015</span>&nbsp;·&nbsp;Nicola Iarocci</div></header><div class=post-content><p>People keep telling me that they want to validate class and instance attributes (object properties) with <a href=https://github.com/nicolaiarocci/cerberus>Cerberus</a>. While it certainly wasn’t conceived with that goal in mind, it is actually very possible to leverage both the Python <a href=https://docs.python.org/2/reference/datamodel.html>data model</a> and Cerberus <a href=http://cerberus.readthedocs.org/en/latest/#custom-validators>extensibility</a> to achieve object validation.</p><h2 id=nuts--bolts>Nuts & Bolts<a hidden class=anchor aria-hidden=true href=#nuts--bolts>#</a></h2><p>Let’s say that we have a simple class:</p><pre><code>&gt;&gt;&gt; class Person(object):
...     pass
</code></pre><p>We create a <code>Person</code> instance and add a few properties and values:</p><pre><code>&gt;&gt;&gt; p = Person()
&gt;&gt;&gt; p.name = &quot;bill&quot;
&gt;&gt;&gt; p.age = 44
</code></pre><p>Now let’s instance a Cerberus Validator and set up some validation rules for it:</p><pre><code>&gt;&gt;&gt; from Cerberus import Validator
&gt;&gt;&gt; schema = {
...     'name': {'type': 'string'},
...     'age': {'type': 'integer', 'min': 0}
... }
&gt;&gt;&gt; v = Validator(schema)
</code></pre><p>As you probably know already, all Python user objects have a <code>__dict__</code> magic method which exposes class and instance attributes as a dictionary. This means that we can also query our class like this:</p><pre><code>&gt;&gt;&gt; p.__dict__
{'name': 'bill', 'age': 44}

&gt;&gt;&gt; p.__dict__['age']
44
</code></pre><p>You see where we are going with this: we can exploit the <code>__dict__</code> method in order to let Cerberus perform validation on our object:</p><pre><code>&gt;&gt;&gt; v.validate(p.__dict__)
True
</code></pre><p>Validation succeeds because current attribute values do not break any rule. However, if we break the rules we do get what we deserve:</p><pre><code>&gt;&gt;&gt; p.age = -1
&gt;&gt;&gt; v.validate(p.__dict__)
False

&gt;&gt;&gt; v.errors
{'age': 'min value is 0'}
</code></pre><p>This works, but is somewhat clumsy. We can do better.</p><h2 id=a-custom-object-validator>A Custom Object Validator<a hidden class=anchor aria-hidden=true href=#a-custom-object-validator>#</a></h2><p>How about letting the Validator do the work for us? We could subclass the standard Validator and extend it to natively support object validation.</p><pre><code>&gt;&gt;&gt; class ObjectValidator(Validator):
...     def validate_object(self, obj):
...         return self.validate(obj.__dict__)
...

&gt;&gt;&gt; v = ObjectValidator(schema)
&gt;&gt;&gt; v.validate_object(p)
False

&gt;&gt;&gt; v.errors
{'age': 'min value is 0'}

&gt;&gt;&gt; p.age = 44
&gt;&gt;&gt; v.validate_object(p)
True
</code></pre><p>Much better. But what happens if we add a new property and then validate the object?</p><pre><code>&gt;&gt;&gt; p.lastname = 'white'
&gt;&gt;&gt; v.validate_object(p)
False

&gt;&gt;&gt; v.errors
{'lastname': 'unknown field'}
</code></pre><p>Validation fails because by default unknown fields are not allowed. This might not be the desired behaviour. If this is the case, we simply need to update the helper method in our custom validator class:</p><pre><code>&gt;&gt;&gt; class ObjectValidator(Validator):
...     def validate_object(self, obj):
...         self.allow_unknown = True
...         return self.validate(obj.__dict__)

&gt;&gt;&gt; v.validate_object(p)
True
</code></pre><p>By setting <code>allow_unknown</code> to <code>True</code> we <a href=http://cerberus.readthedocs.org/en/latest/#allowing-the-unknown>let unknown fields be ignored</a> by validation. If we are not concerned by state changes between calls we might conveniently choose to move the setting of <code>allow_unknown</code> to the <code>__init__</code> method so it gets executed only once.</p><p>Looks good so far. We can validate simple objects. But what about complex ones like those exposing other objects as attributes? This is going to require some more tinkering.</p><h2 id=validating-complex-objects>Validating Complex Objects<a hidden class=anchor aria-hidden=true href=#validating-complex-objects>#</a></h2><p>It would be super handy if we could add support for an <code>object</code> data type and then provide a validation schema for it, like we already do with the <code>dict</code> and <code>list</code> types. A revised validation schema would then look like this:</p><pre><code>&gt;&gt;&gt; schema = {
...     'name': {'type': 'string'},
...     'age': {'type': 'integer', 'min': 0},
...     'address': {
...         'type': 'object',
            'schema': {
...             'street': {'type': 'string'},
...             'zip': {'type': 'integer'}
...         }
...     }
... }
</code></pre><p>We could then validate it like so:</p><pre><code>&gt;&gt;&gt; class Address
...     pass

&gt;&gt;&gt; addr = Address()
&gt;&gt;&gt; addr.street = 'Lexington'
&gt;&gt;&gt; addr.zip = 50238
&gt;&gt;&gt; p.address = addr

&gt;&gt;&gt; v.validate_object(p)
True

&gt;&gt;&gt; p.address.zip = 'not a number'
&gt;&gt;&gt; v.validate_object(p)
False

&gt;&gt;&gt; v.errors
{'address': {'zip': 'must be of integer type'}}
</code></pre><p>It turns out this is also very achievable. We can leverage Cerberus <a href=http://cerberus.readthedocs.org/en/latest/#adding-new-data-types>data type extensibility model</a> to add support for the <code>object</code> type. Then it is just a matter of handling the new type when validating the <code>schema</code> rule. I’m not going into details here but you can check <a href=https://gist.github.com/nicolaiarocci/829c98eb5f8b4e9c96c1>Validating complex objects with Cerberus</a>, a trivial implementation I posted as a GitHub gist.</p><h2 id=closing-note>Closing note<a hidden class=anchor aria-hidden=true href=#closing-note>#</a></h2><p>You might be wondering why don’t I add object validation to Cerberus core. Actually, I don’t rule out this possibility but see I like to keep tools as simple, targeted and focused as possible. Besides, there are other object validation tools out there, so adding a new flavour does not seem very useful to me (but let me know if you feel otherwise.) Though as we have seen, if you want to validate user objects with Cerberus, you can do that easily enough.</p><p>If you want to get in touch, I am @<a href=http://twitter.com/nicolaiarocci>nicolaiarocci</a> on Twitter.</p><i>Subscribe to my <a href=https://buttondown.email/nicolaiarocci>newsletter</a> or the <a href=/index.xml>RSS
feed</a>. Follow me on <a href=https://fosstodon.org/@nicola>Mastodon</a> or <a href=https://twitter.com/nicolaiarocci>X</a>.</div><footer class=post-footer><ul class=post-tags><li><a href=https://nicolaiarocci.com/tags/cerberus/>cerberus</a></li><li><a href=https://nicolaiarocci.com/tags/python/>python</a></li></ul></footer></article></main><footer class=footer><span>Produced / Written / Maintained by <a href=/>Nicola Iarocci</a> since 2010</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>